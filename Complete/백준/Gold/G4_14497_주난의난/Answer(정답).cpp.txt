#include<bits/stdc++.h>
using namespace std;

int                   n, m;                       // 맵 크기
int                   startY, startX, endY, endX; // 주난이 위치(startY,startX), 범인 위치(endY,endX)
char                  a[301][301];                // 배열 (0, 1, *, #)
int                   visited[301][301];          // 방문 체크 배열 (점프 횟수 저장)
int                   cnt = 0;                    // 현재 점프 횟수
queue<pair<int,int>>  currentQ;                   // 현재 큐
const int             dy[4] = {-1, 0, 1, 0};      // 상하좌우 y 방향
const int             dx[4] = {0, 1, 0, -1};      // 상하좌우 x 방향

int main()
{
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    // 입력: 맵 크기
    cin >> n >> m;

    // 입력: 주난이 위치, 범인 위치 (1-based → 0-based)
    cin >> startY >> startX >> endY >> endX;
    startY--; startX--; endY--; endX--;

    // 입력: 맵 배열
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }

    // BFS 시작: 주난이 위치부터
    currentQ.emplace(startY,startX);
    visited[startY][startX] = 1;

    // 범인 위치의 칸이 '0'이 될 때까지 반복
    while (a[endY][endX] != '0')
    {
        cnt++;                        // 점프 횟수 증가
        queue<pair<int,int>> temp;    // 다음 큐 (1을 만난 좌표들)

        // 현재 큐에 있는 모든 좌표 처리
        while (!currentQ.empty())
        {
            int y = currentQ.front().first;
            int x = currentQ.front().second;
            currentQ.pop();

            // 상하좌우 탐색
            for (int i = 0; i < 4; i++)
            {
                int ny = y + dy[i];
                int nx = x + dx[i];

                // 범위 체크, 방문 체크
                if (ny < 0 || ny >= n || nx < 0 || nx >= m || visited[ny][nx]) continue;

                visited[ny][nx] = cnt;  // 현재 점프 횟수 저장
                
                // 1 또는 # 또는 *을 만나면 (장애물)
                if (a[ny][nx] != '0')
                {
                    a[ny][nx] = '0';          // 0으로 바꿈 (쓰러뜨림)
                    temp.emplace(ny, nx);     // 다음 큐에 추가(멈춤!)
                }
                // 0을 만나면 (빈 공간)
                else
                {
                    currentQ.emplace(ny, nx);  // 현재 큐에 추가 (계속 퍼짐!)
                }
            }
        }

        currentQ = temp;  // 현재 큐를 다음 큐로 교체
    }

    // 범인 위치에 도달한 점프 횟수 출력
    cout << visited[endY][endX] << "\n";

    return 0;
}
