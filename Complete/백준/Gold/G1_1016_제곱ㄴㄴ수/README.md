**📅 작성일**: 2025-10-18

## 🔗 문제 링크
[백준 1016번 - 제곱 ㄴㄴ 수](https://www.acmicpc.net/problem/1016)

---

## 🤔 접근법

제곱수로 나누어떨어지지 않는 수의 개수를 구하는 문제.

범위가 min ≤ 10^12로 엄청나게 크기 때문에, 모든 수를 일일이 체크할 수 없다.

하지만 **범위의 길이**는 최대 10^6이므로, 에라토스테네스의 체를 응용할 수 있다!

핵심은 **절대값이 아닌 상대 위치**를 인덱스로 사용하는 것.

---

## 💡 정답 풀이 방법

**알고리즘**: 에라토스테네스의 체 응용 (Sieve of Eratosthenes Variant)

**핵심 아이디어**:
```
1. start~end 범위를 0~(end-start) 배열로 매핑 (상대 위치 활용)
2. 2^2, 3^2, 4^2, ... 각 제곱수의 배수들을 false로 마킹
3. true로 남아있는 개수가 제곱ㄴㄴ수의 개수
```

**시간 복잡도**: O(√end × (end-start))
- 외부 루프: k = 2 ~ √end (최대 10^6)
- 내부 루프: 각 제곱수의 배수 마킹 (최대 10^6개)

**공간 복잡도**: O(end - start)
- sieve 배열 크기: 최대 10^6

---

## 🔑 핵심 포인트

### 1️⃣ 상대 인덱스 매핑

**❌ 불가능한 접근**: 절대값 사용
```cpp
// start = 1,000,000,000,000일 때 배열 크기 1조? → 메모리 초과!
vector<bool> sieve(end + 1);  // ❌
```

**✅ 정답 접근**: 상대 위치 사용
```cpp
// 범위 길이만큼만 배열 생성 (최대 100만)
vector<bool> sieve(end - start + 1);  // ✅

// sieve[0]  → 실제 값 start
// sieve[1]  → 실제 값 start+1
// sieve[i]  → 실제 값 start+i
```

### 2️⃣ 첫 배수 위치 계산 (모듈러 연산)

**핵심 공식**:
```cpp
long_t i = (s - (start % s)) % s;  // start~end 범위에서 s의 첫 배수 위치
```

**왜 이 공식인가?**

제곱수 `s`의 배수는 `0, s, 2s, 3s, ...`

`start ~ end` 범위에서 `s`의 첫 배수를 찾으려면:
- `start % s`를 계산하면 → start가 s의 몇 번째 위치에 있는지 알 수 있음
- `s - (start % s)`를 계산하면 → 다음 배수까지 몇 칸 남았는지
- 단, `start`가 이미 s의 배수면 → `% s`로 0으로 만들어줌

**예시 1**: start=10, s=4 (제곱수 4의 배수 찾기)
```
10 % 4 = 2         (10은 4의 배수에서 2칸 지남)
4 - 2 = 2          (다음 배수까지 2칸 남음)
2 % 4 = 2          (첫 배수는 인덱스 2 → 실제 값 10+2=12)

검증: 12는 4의 배수 ✅
```

**예시 2**: start=12, s=4 (start가 이미 배수인 경우)
```
12 % 4 = 0         (12는 이미 4의 배수)
4 - 0 = 4
4 % 4 = 0          (첫 배수는 인덱스 0 → 실제 값 12)

검증: 12는 4의 배수 ✅
```

### 3️⃣ 제곱수 범위 최적화

```cpp
for (long_t k = 2; k * k <= end; k++)  // end까지만 체크
```

**왜 √end까지만 체크하는가?**
- k^2 > end이면, k^2의 배수는 end를 초과함
- 따라서 start~end 범위에 영향을 주지 않음

**예시**: end = 17일 때
```
k=2 → 2^2 = 4  ≤ 17 ✅ (체크 필요)
k=3 → 3^2 = 9  ≤ 17 ✅ (체크 필요)
k=4 → 4^2 = 16 ≤ 17 ✅ (체크 필요)
k=5 → 5^2 = 25 > 17 ❌ (체크 불필요, 루프 종료)
```

### 4️⃣ unsigned long long 사용 이유

```cpp
typedef unsigned long long long_t;
```

**왜 unsigned를 사용하는가?**
- min, max 최대값: 10^12
- `long long` 범위: -2^63 ~ 2^63-1 (약 -9×10^18 ~ 9×10^18)
- 충분하지만, `k * k` 연산 시 오버플로우 가능성 존재
- `unsigned long long`은 0 ~ 2^64-1 (약 1.8×10^19)
- 음수가 없고 범위가 2배 → 더 안전

---

## 📊 예제 1 상세 계산 과정

**입력**: `1 10`

### 초기 상태
```
범위: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
sieve: [T, T, T, T, T, T, T, T, T, T]
         ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑
인덱스:  0  1  2  3  4  5  6  7  8  9
실제값:  1  2  3  4  5  6  7  8  9 10
```

### k=2, s=4 (제곱수 4의 배수 제거)
```
첫 배수 계산:
  i = (4 - (1 % 4)) % 4
    = (4 - 1) % 4
    = 3

마킹 위치: i=3, i=7 (간격 4)
실제 값:   4,   8

sieve: [T, T, T, F, T, T, T, F, T, T]
                ↑              ↑
               4는            8은
            제곱ㄴㄴ수        제곱ㄴㄴ수
             아님!            아님!
```

### k=3, s=9 (제곱수 9의 배수 제거)
```
첫 배수 계산:
  i = (9 - (1 % 9)) % 9
    = (9 - 1) % 9
    = 8

마킹 위치: i=8
실제 값:   9

sieve: [T, T, T, F, T, T, T, F, F, T]
                               ↑
                              9는
                           제곱ㄴㄴ수
                             아님!
```

### k=4일 때 루프 종료
```
k * k = 16 > 10이므로 종료
```

### 최종 결과
```
sieve: [T, T, T, F, T, T, T, F, F, T]
        ↑  ↑  ↑     ↑  ↑  ↑        ↑
        1  2  3     5  6  7       10

제곱ㄴㄴ수: 1, 2, 3, 5, 6, 7, 10 → 총 7개
```

**출력**: `7`

---

## 📊 예제 2 상세 계산 과정

**입력**: `15 15`

### 초기 상태
```
범위: [15]
sieve: [T]
        ↑
인덱스: 0
실제값: 15
```

### k=2, s=4 (제곱수 4의 배수 제거)
```
첫 배수 계산:
  i = (4 - (15 % 4)) % 4
    = (4 - 3) % 4
    = 1

마킹 위치: i=1 (범위 초과, sieve.size()=1)
→ 마킹 없음
```

### k=3, s=9 (제곱수 9의 배수 제거)
```
첫 배수 계산:
  i = (9 - (15 % 9)) % 9
    = (9 - 6) % 9
    = 3

마킹 위치: i=3 (범위 초과, sieve.size()=1)
→ 마킹 없음
```

### k=4일 때 루프 종료
```
k * k = 16 > 15이므로 종료
```

### 최종 결과
```
sieve: [T]
        ↑
       15

15는 제곱수로 나누어떨어지지 않음 → 제곱ㄴㄴ수!
```

**출력**: `1`

---

## 🔍 제곱ㄴㄴ수 판정 예시

### ✅ 제곱ㄴㄴ수
```
1  = 1             → 제곱수 배수 없음 ✅
2  = 2             → 제곱수 배수 없음 ✅
3  = 3             → 제곱수 배수 없음 ✅
5  = 5             → 제곱수 배수 없음 ✅
6  = 2 × 3         → 제곱수 배수 없음 ✅
7  = 7             → 제곱수 배수 없음 ✅
10 = 2 × 5         → 제곱수 배수 없음 ✅
```

### ❌ 제곱ㄴㄴ수 아님
```
4  = 2 × 2 = 4×1   → 4(2^2)로 나누어떨어짐 ❌
8  = 2 × 2 × 2 = 4×2 → 4(2^2)로 나누어떨어짐 ❌
9  = 3 × 3 = 9×1   → 9(3^2)로 나누어떨어짐 ❌
12 = 2 × 2 × 3 = 4×3 → 4(2^2)로 나누어떨어짐 ❌
16 = 2^4 = 4×4     → 4(2^2)로 나누어떨어짐 ❌
18 = 2 × 3^2 = 9×2 → 9(3^2)로 나누어떨어짐 ❌
```

---

## 🚨 주의사항

1. **unsigned long long 사용**: min, max가 10^12까지 가능
2. **상대 인덱싱**: `sieve[i]`는 실제 값 `start+i`를 의미
3. **첫 배수 공식**: `(s - (start % s)) % s`로 정확히 계산
4. **범위 체크**: `k * k <= end`로 불필요한 연산 제거
5. **배열 크기**: `end - start + 1` (양 끝 포함)
