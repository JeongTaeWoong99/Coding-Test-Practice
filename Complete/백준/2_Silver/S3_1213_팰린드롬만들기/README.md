**📅 작성일**: 2025-10-17

## 🔗 문제 링크
[백준 1213번 - 팰린드롬 만들기](https://www.acmicpc.net/problem/1213)

**난이도**: Silver 3

---

## 🤔 접근법

주어진 문자열을 재배치하여 사전순으로 가장 앞서는 팰린드롬을 만드는 문제.

**핵심**: 팰린드롬의 특성상 홀수 개수의 문자는 최대 1개만 존재할 수 있음 (중앙에 배치).

알파벳 개수를 카운트한 후, 조건을 만족하면 앞쪽 절반 + 중간값 + 뒤쪽 절반(역순)으로 구성.

---

## 💡 정답 풀이 방법

**알고리즘** : 그리디(Greedy) + 문자열

**핵심 아이디어**:
```
1. 각 알파벳의 개수를 카운트 (arr[26])
2. 홀수 개수인 알파벳이 2개 이상이면 팰린드롬 불가능 → "I'm Sorry Hansoo" 출력
3. 홀수 개수인 알파벳이 1개 이하면:
   - 홀수인 알파벳 1개는 중간(mid)에 배치
   - 나머지 짝수 개수 알파벳들을 절반씩 나눠서 앞(front)/뒤(back)에 배치
4. 사전순 가장 앞서는 답을 위해 A부터 순서대로 배치
5. front + mid + reverse(back) 출력
```

---

## 🔑 핵심 개념

### 1️⃣ 팰린드롬 조건

**팰린드롬이란?**
- 앞에서 읽으나 뒤에서 읽으나 같은 문자열
- 예: "AABCBAA", "ABBA", "ABA"

**팰린드롬 가능 조건**:

| 문자열 길이 | 홀수 개수 문자 조건 |
|----------|----------------|
| 짝수 | 홀수 개수 문자가 **0개** |
| 홀수 | 홀수 개수 문자가 **정확히 1개** (중앙 배치) |

**예시**:
```
✅ "AABBCC" (길이 6, 짝수)
   A=2, B=2, C=2 → 홀수 개수 문자 0개 → 가능!
   결과: "ABCCBA"

✅ "AABBC" (길이 5, 홀수)
   A=2, B=2, C=1 → 홀수 개수 문자 1개 (C) → 가능!
   결과: "ABCBA"

❌ "AABC" (길이 4, 짝수)
   A=2, B=1, C=1 → 홀수 개수 문자 2개 → 불가능!
```

### 2️⃣ 그리디 전략 - 사전순 최소

**왜 A부터 순서대로 배치하는가?**

사전순으로 가장 앞서는 답을 만들기 위해 **알파벳 순서대로(A→Z) 앞쪽에 배치**해야 함!

**예시 - "ABACABA"**:
```
알파벳 카운트: A=4, B=2, C=1

1단계: 홀수 체크
   C=1 (홀수) → mid = "C"
   arr[C]-- → A=4, B=2, C=0

2단계: A부터 순서대로 절반씩 배치
   i=0 (A): arr[0]=4 → 절반=2
      front = "AA"
      back  = "AA"

   i=1 (B): arr[1]=2 → 절반=1
      front = "AAB"
      back  = "AAB"

3단계: back 뒤집기
   back = "BAA"

4단계: 결합
   front + mid + back = "AAB" + "C" + "BAA" = "AABCBAA" ✅

다른 팰린드롬들: "ABACABA", "BAACAAB", ...
→ "AABCBAA"가 사전순으로 가장 앞섬!
```

### 3️⃣ 알고리즘 단계별 상세

#### 🔸 1단계: 알파벳 카운트
```cpp
for (int i = 0; i < s.length(); i++)
{
    arr[s[i] - 'A']++;  // A=0, B=1, ..., Z=25
}
```

#### 🔸 2단계: 홀수 개수 체크
```cpp
for (int i = 0; i < 26; i++)
{
    if (arr[i] % 2 == 1)  // 홀수 개수 발견
    {
        if (mid.empty())  // 첫 홀수
        {
            mid += (char)(i + 'A');  // 중간값 저장
            arr[i]--;                // 개수 1 감소 (짝수로 만듦)
        }
        else  // 이미 홀수가 있음 → 불가능
        {
            flag = true;
            break;
        }
    }
}
```

**핵심 포인트**:
- `mid.empty()`: 첫 번째 홀수인지 확인
- `arr[i]--`: 홀수를 짝수로 만들어서 다음 단계에서 절반씩 나눔
- `flag = true`: 2개 이상 홀수 발견 시 불가능 처리

#### 🔸 3단계: 짝수 개수 알파벳 배치
```cpp
for (int i = 0; i < 26; i++)
{
    if (arr[i] > 0)
    {
        for (int j = 0; j < arr[i] / 2; j++)
        {
            front += (char)(i + 'A');
            back  += (char)(i + 'A');
        }
    }
}
```

**핵심 포인트**:
- `arr[i] / 2`: 절반씩만 배치 (나머지 절반은 대칭 위치)
- A부터 순서대로 배치 → 사전순 최소 보장
- front와 back에 동일하게 추가

#### 🔸 4단계: 팰린드롬 완성
```cpp
reverse(back.begin(), back.end());  // back 뒤집기
cout << front << mid << back << '\n';
```

---

**⏱️ 시간복잡도**: O(N)

**💾 공간복잡도**: O(N)
