**📅 작성일**: 2025-10-15

## 🔗 문제 링크

[백준 1620번 - 나는야 포켓몬 마스터 이다솜](https://www.acmicpc.net/problem/1620)

**난이도**: Silver 4

---

## 🤔 접근법

포켓몬 도감 문제.

N개의 포켓몬 이름이 주어지고, M개의 질문에 대해 답하는 문제.

질문이 **숫자**면 → 해당 번호의 포켓몬 이름 출력

질문이 **문자**면 → 해당 이름의 포켓몬 번호 출력

**핵심:** 양방향 검색이 필요하므로 **두 개의 map**을 사용!

---

## 💡 정답 풀이 방법

**알고리즘**: 해시맵(map) 활용

**핵심 아이디어**:
```
1. 포켓몬 이름 → 번호 (map<string, int>)
2. 포켓몬 번호 → 이름 (map<int, string>)
3. 입력이 숫자인지 문자인지 판별 후 해당 map에서 검색
```

---

## 🔑 핵심 포인트

### 1️⃣ 양방향 검색을 위한 두 개의 map

```cpp
map<string, int>    mp1; // 포켓몬 이름 → 번호
map<int,    string> mp2; // 포켓몬 번호 → 이름

for (int i = 0; i < N; i++)
{
    cin >> temp;
    mp1[temp]  = i + 1; // 문자 키 - 숫자 값
    mp2[i + 1] = temp;  // 숫자 키 - 문자 값
}
```

**✅ 핵심**:
- 번호는 1부터 시작하므로 `i + 1`로 저장
- 두 개의 map으로 O(log N) 시간에 양방향 검색 가능

### 2️⃣ 입력 판별: 숫자 vs 문자열

```cpp
if (atoi(temp.c_str()) == 0) // 문자가 들어온 경우
{
    cout << mp1[temp] << "\n";
}
else // 숫자가 들어온 경우
{
    cout << mp2[atoi(temp.c_str())] << "\n";
}
```

**✅ 핵심**: `atoi()` 함수 활용
- `atoi("피카츄")` → 0 (문자열은 0 반환)
- `atoi("25")` → 25 (숫자 문자열은 정수로 변환)
- **주의** : "0"이 입력되면 오답! (하지만 문제 조건상 1번부터 시작하므로 "0"은 없음)

### 3️⃣ map의 시간복잡도

```cpp
map<string, int> mp1;
mp1[temp] = i + 1;         // 삽입: O(log N)
cout << mp1[temp] << "\n"; // 검색: O(log N)
```

**✅ 핵심**: map은 Red-Black Tree 기반
- 삽입 : O(log N)
- 검색 : O(log N)
- unordered_map을 쓰면 평균 O(1)이지만, 최악의 경우 O(N)
- 이 문제는 N, M ≤ 100,000이므로 map으로 충분

---

## 🚨 "맞왜틀" 방지 포인트

### 1️⃣ 번호는 1부터 시작!

```cpp
❌ mp1[temp] = i;      // 0부터 시작 → 틀림!
✅ mp1[temp] = i + 1;  // 1부터 시작 → 정답!
```

**이유:**
- 문제에서 "1번 포켓몬, 2번 포켓몬, ..."으로 시작
- 배열 인덱스 i는 0부터 시작하므로 `i + 1` 필수!

### 2️⃣ atoi()의 함정

```cpp
❌ if (isdigit(temp[0]))  // "0"이 입력되면 오답 가능!

✅ if (atoi(temp.c_str()) == 0)  // 숫자 문자열은 0이 아님
```

**이유:**
- `atoi("0")` → 0 (문자로 인식됨)
- 하지만 문제 조건상 1번부터 시작하므로 "0"은 입력되지 않음
- 만약 "0"이 가능하다면 `isdigit()` 사용 필요

### 3️⃣ ※ 입출력 최적화 필수

```cpp
✅ ios_base::sync_with_stdio(false);
   cin.tie(NULL);
   cout.tie(NULL);
```

**이유:**
- N, M ≤ 100,000
- 최대 200,000번의 입출력 발생
- 최적화 없으면 시간 초과 가능!

---

## 📊 시간복잡도 분석

**전체 시간복잡도**: **O((N + M) × log N)**

**상세 분석**:
```
1. 포켓몬 입력 및 map 삽입 : O(N × log N)
   - N번 반복
   - 각 삽입마다 O(log N)

2. 질문 처리 : O(M × log N)
   - M번 반복
   - 각 검색마다 O(log N)

총합 : O(N × log N + M × log N) = O((N + M) × log N)
```

**시간 제한 체크**:
- N, M ≤ 100,000
- (N + M) × log N ≈ 200,000 × 17 ≈ 3,400,000
- **340만 연산** < **1억** → 시간 내 통과 가능 ✅

---

## 💾 공간복잡도

**O(N)**
- `mp1` : N개의 (string, int) 쌍
- `mp2` : N개의 (int, string) 쌍
- 총 2N개의 데이터 저장

---

## ✅ map VS unordered_map 선택

| 항목 | map | unordered_map |
|-----|-----|---------------|
| **시간복잡도** | O(log N) | 평균 O(1), 최악 O(N) |
| **정렬 여부** | 정렬됨 (Red-Black Tree) | 정렬 안 됨 (해시 테이블) |
| **적합한 경우** | 안정적인 성능 필요 시 | 평균 성능 최적화 필요 시 |

**이 문제**: map으로 충분 (안정적인 O(log N))

---

**⏱️ 시간복잡도** : O((N + M) × log N)

**💾 공간복잡도** : O(N)
