**📅 작성일**: 2025-10-15

## 🔗 문제 링크

[백준 2529번 - 부등호](https://www.acmicpc.net/problem/2529)

**난이도**: Silver 1

---

## 🤔 접근법

k개의 부등호 기호 사이에 0~9 숫자를 하나씩 넣어서 부등호 관계를 만족시키는 최댓값과 최솟값을 구하는 문제.

**핵심은 백트래킹**으로 모든 가능한 숫자 조합을 탐색하면서, 부등호 조건을 만족하는 경우만 선택하는 것!

---

## 💡 정답 풀이 방법

**알고리즘** : 백트래킹 (Backtracking) + 완전 탐색

**핵심 아이디어**:
```
1. 0~9 숫자를 하나씩 선택하면서 재귀적으로 탐색
2. 이미 사용한 숫자는 use 배열로 중복 방지
3. 이전 숫자와 현재 숫자가 부등호 조건을 만족하는지 검증
4. K+1개 숫자를 모두 채우면 결과 벡터에 저장
5. 결과를 사전순 정렬하여 최댓값(마지막)과 최솟값(첫번째) 출력
```

---

## 🔑 핵심 포인트

### 1️⃣ 백트래킹 패턴

```cpp
for (int i = 0; i <= 9; i++)
{
    if (use[i]) continue; // 이미 사용한 숫자는 건너뛰기

    if (idx == 0 || OperCheck(numString[idx - 1], i + '0', arr[idx - 1]))
    {
        use[i] = true;                                // 숫자 사용 표시
        Recursion(idx + 1, numString + to_string(i)); // 재귀 호출
        use[i] = false;                               // 백트래킹: 사용 해제 ⭐
    }
}
```

**✅ 핵심**: 재귀 반환 후 `use[i] = false`로 숫자 사용 해제
- 다른 경로에서 해당 숫자를 다시 사용할 수 있도록 함
- 이것이 **백트래킹의 핵심**!

### 2️⃣ 부등호 조건 검증

```cpp
bool OperCheck(char A, char B, char op)
{
    if (A < B && op == '<') return true;
    if (A > B && op == '>') return true;
    return false;
}
```

**✅ 핵심**: 문자(char) 비교로 부등호 조건 검증
- `'0' < '1' < ... < '9'` (ASCII 코드 순서)
- 정수로 변환할 필요 없이 문자 그대로 비교 가능

### 3️⃣ 문자열 사전순 정렬

```cpp
sort(results.begin(), results.end());
cout << results[results.size() - 1] << "\n" << results[0] << "\n";
```

**✅ 핵심**: 문자열 사전순 정렬 활용
- `"021" < "897" < "9876543210"` (사전순)
- 마지막 요소 = 최댓값, 첫 번째 요소 = 최솟값

---

## 📊 재귀 동작 상세 분석 (테스트 케이스)

### 🎯 입력
```
2
< >
```

### 📌 핵심 코드
```cpp
// 조건 검사
if (idx == 0 || OperCheck(numString[idx - 1], i + '0', arr[idx - 1]))

// OperCheck 함수
bool OperCheck(char A, char B, char op)
{
    if (A < B && op == '<') return true;
    if (A > B && op == '>') return true;
    return false;
}
```

### 🔍 재귀 트리 전개 (상세)

```
                     Recursion(0, "")
                     idx=0, numString=""
                     use[] = [0,0,0,0,0,0,0,0,0,0]
                          |
        ┌─────────────────┼─────────────────┐
        i=0               i=1               i=8               i=9

┌───────────────────────────────────────────────────────────────┐
│ ✅ i=0 선택                                                    │
├───────────────────────────────────────────────────────────────┤
│ if (idx == 0 || OperCheck(...))                              │
│    → idx == 0 이므로 조건 통과! (첫 번째 숫자는 무조건 가능)    │
│                                                               │
│ use[0] = true                                                 │
│ Recursion(1, "0")  ← 재귀 호출                                │
└───────────────────────────────────────────────────────────────┘

              Recursion(1, "0")
              idx=1, numString="0"
              use[] = [1,0,0,0,0,0,0,0,0,0]
              arr[0] = '<'  (0번째 부등호)
                   |
    ┌──────────────┼──────────────┐
    i=1            i=2            i=9

┌───────────────────────────────────────────────────────────────┐
│ ✅ i=1 선택 시도                                               │
├───────────────────────────────────────────────────────────────┤
│ if (idx == 0 || OperCheck(numString[idx-1], i+'0', arr[idx-1]))│
│    → OperCheck(numString[0], '1', '<')                        │
│    → OperCheck('0', '1', '<')                                 │
│    → '0' < '1' 이고 op == '<' → true ✅                       │
│                                                               │
│ use[1] = true                                                 │
│ Recursion(2, "01")  ← 재귀 호출                               │
└───────────────────────────────────────────────────────────────┘

              Recursion(2, "01")
              idx=2, numString="01"
              use[] = [1,1,0,0,0,0,0,0,0,0]
              arr[1] = '>'  (1번째 부등호)
                   |
    ┌──────────────┼──────────────┐
    i=0(skip)      i=2            i=9

┌───────────────────────────────────────────────────────────────┐
│ ❌ i=2 선택 시도                                               │
├───────────────────────────────────────────────────────────────┤
│ if (idx == 0 || OperCheck(numString[idx-1], i+'0', arr[idx-1]))│
│    → OperCheck(numString[1], '2', '>')                        │
│    → OperCheck('1', '2', '>')                                 │
│    → '1' > '2'? → false ❌                                    │
│                                                               │
│ 조건 불만족! 재귀 호출 안 함                                    │
│ i=2는 스킵하고 다음 i=3으로                                     │
└───────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────┐
│ ❌ i=0 선택 시도                                               │
├───────────────────────────────────────────────────────────────┤
│ if (use[0]) continue;                                         │
│    → use[0] == true (이미 사용중) → continue ❌               │
│                                                               │
│ 이미 사용한 숫자이므로 스킵!                                    │
└───────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────┐
│ ⏪ 백트래킹 발생                                               │
├───────────────────────────────────────────────────────────────┤
│ Recursion(2, "01")에서 모든 i(2~9)를 시도했지만               │
│ '1' > '2', '1' > '3', ... 모두 false                          │
│                                                               │
│ return으로 Recursion(1, "0")으로 복귀                         │
│ use[1] = false  ← 백트래킹: 1 사용 해제!                      │
└───────────────────────────────────────────────────────────────┘

              다시 Recursion(1, "0")으로 복귀
              use[] = [1,0,0,0,0,0,0,0,0,0]  (1이 해제됨!)
                   |
              이제 i=2 시도

┌───────────────────────────────────────────────────────────────┐
│ ✅ i=2 선택 시도 (i=1 백트래킹 후)                             │
├───────────────────────────────────────────────────────────────┤
│ if (idx == 0 || OperCheck(numString[idx-1], i+'0', arr[idx-1]))│
│    → OperCheck(numString[0], '2', '<')                        │
│    → OperCheck('0', '2', '<')                                 │
│    → '0' < '2' 이고 op == '<' → true ✅                       │
│                                                               │
│ use[2] = true                                                 │
│ Recursion(2, "02")  ← 재귀 호출                               │
└───────────────────────────────────────────────────────────────┘

              Recursion(2, "02")
              idx=2, numString="02"
              use[] = [1,0,1,0,0,0,0,0,0,0]
              arr[1] = '>'  (1번째 부등호)
                   |
    ┌──────────────┼──────────────┐
    i=0(skip)      i=1            i=9

┌───────────────────────────────────────────────────────────────┐
│ ✅ i=1 선택 시도                                               │
├───────────────────────────────────────────────────────────────┤
│ if (idx == 0 || OperCheck(numString[idx-1], i+'0', arr[idx-1]))│
│    → OperCheck(numString[1], '1', '>')                        │
│    → OperCheck('2', '1', '>')                                 │
│    → '2' > '1' 이고 op == '>' → true ✅                       │
│                                                               │
│ use[1] = true                                                 │
│ Recursion(3, "021")  ← 재귀 호출                              │
└───────────────────────────────────────────────────────────────┘

              Recursion(3, "021")
              idx=3, K+1=3
              use[] = [1,1,1,0,0,0,0,0,0,0]

┌───────────────────────────────────────────────────────────────┐
│ 🎉 기저 조건 도달!                                             │
├───────────────────────────────────────────────────────────────┤
│ if (idx == K + 1)  → if (3 == 3)                             │
│                                                               │
│ results.push_back("021")  ← 결과 저장!                        │
│ return                                                        │
└───────────────────────────────────────────────────────────────┘
```

### 🔄 계속 탐색 (다른 경로)

```
... (위 과정 반복으로 모든 가능한 조합 탐색)

최종적으로 찾은 조합들:
  "021", "102", "120", "201", "210", ..., "897", ...
```

### 📋 최종 정렬 및 출력

```cpp
sort(results.begin(), results.end());
// results = ["021", "102", "120", ..., "879", "897", ...]

cout << results[results.size() - 1] << "\n" << results[0] << "\n";
// 최댓값: "897"
// 최솟값: "021"
```

---

## 🔑 핵심 이해 포인트

### ✅ 조건 검사 시점
```cpp
if (idx == 0 || OperCheck(numString[idx - 1], i + '0', arr[idx - 1]))
```

**idx == 0**: 첫 번째 숫자는 비교할 이전 숫자가 없으므로 무조건 통과

**OperCheck(...)**:
- `numString[idx - 1]`: 이전에 선택한 숫자 (문자)
- `i + '0'`: 현재 시도하는 숫자 (정수 → 문자 변환)
- `arr[idx - 1]`: 이전 숫자와 현재 숫자 사이의 부등호

**예시**:
```
numString = "02", idx = 2, i = 1, arr[1] = '>'
→ OperCheck('2', '1', '>')
→ '2' > '1'? Yes! → true ✅
```

### ✅ 재귀 호출
```cpp
Recursion(idx + 1, numString + to_string(i));
```

**동작**:
- `idx + 1`: 다음 위치로 이동
- `numString + to_string(i)`: 현재 숫자를 문자열에 추가

**예시**:
```
Recursion(1, "0")에서 i=2 선택
→ Recursion(2, "0" + "2")
→ Recursion(2, "02")
```

### ✅ 백트래킹
```cpp
use[i] = true;                                // 사용 표시
Recursion(idx + 1, numString + to_string(i)); // 재귀
use[i] = false;                               // 사용 해제 ⭐
```

**왜 필요한가?**
- 재귀가 끝나고 돌아오면 다른 경로에서 그 숫자를 다시 사용해야 함
- 예: "021" 경로에서 1을 사용했지만, "102" 경로에서는 1을 다시 사용해야 함

---

## ⏱️ 시간복잡도

**최악의 경우**: **O(10!)**

**분석**:
- k=9일 때: 10개 숫자 중 10개를 배치하는 순열 → 10! = 3,628,800
- 부등호 조건으로 많은 경로가 조기에 차단됨 (실제로는 훨씬 적음)
- **1억(10^8) 연산 이하**이므로 시간 내 통과 가능 ✅

**📌 시간복잡도 예측 기준** (C++ 기준):
```
1초 제한 기준:
  - 10^8 연산 : 통과 가능 ✅
  - 10^9 연산 : 경계선 (최적화 필요)
  - 10^10 연산 : 시간 초과 ❌

10! = 3,628,800 ≈ 3.6 × 10^6 < 10^8
→ 완전 탐색으로 해결 가능!
```

**💡**:
- **10!** ≈ **3백만** 정도의 시간복잡도
- **1억 이하**면 완전 탐색(브루트 포스) 가능
- 이 문제는 10! 범위 내이므로 백트래킹 완전 탐색으로 해결!

---

## 💾 공간복잡도

**O(N × M)**
- `use[10]` : 숫자 사용 여부 배열 (상수)
- `results` 벡터 : 최악의 경우 10! = 362만 개 문자열 저장
  - 각 문자열 길이 : 최대 10
  - 총 공간 : 10 × 362만 ≈ 36MB
- 재귀 스택 : O(K+1) = O(10) (상수)

---

## 🎯 핵심 교훈

### ✅ 완전 탐색 가능 여부 판단

**문제 조건 확인**:
- K ≤ 9 → 숫자 10개 배치 → 10! ≈ 360만
- 1초 제한 → 1억 연산 가능
- **360만 < 1억** → 완전 탐색 가능! ✅

### ✅ 백트래킹 핵심

cpp
use[i] = true;   // 선택
Recursion(...);  // 재귀
use[i] = false;  // 선택 취소 (백트래킹) ⭐


### ✅ bool 타입 사용

cpp
bool use[10];  // int보다 명확하고 효율적


### ✅ 명확한 변수명

cpp
// ❌ 모호한 변수명
int n, check[10];
char a[20];
vector<string> ret;
void go(int idx, string num) { }

// ✅ 명확한 변수명
int K;                    // 부등호 개수
bool use[10];            // 숫자 사용 여부
char arr[20];            // 부등호 배열
vector<string> results;  // 결과 저장
void Recursion(int idx, string numString) { }


---

**⏱️ 시간복잡도**: O(10!) ≈ O(3.6 × 10^6) - 완전 탐색 가능

**💾 공간복잡도**: O(N × M) - N개 결과, 각 길이 M
