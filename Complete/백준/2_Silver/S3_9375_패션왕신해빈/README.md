**📅 작성일**: 2025-10-16

## 🔗 문제 링크
[백준 9375번 - 패션왕 신해빈](https://www.acmicpc.net/problem/9375)

**난이도**: Silver 3

---

## 🤔 접근법

의상을 조합하여 만들 수 있는 서로 다른 옷차림의 경우의 수를 구하는 문제.

**핵심**: 각 의상 종류별로 "입거나" 또는 "안 입거나" 두 가지 선택이 가능하고, 최소 한 가지 이상은 입어야 함.

의상 이름은 필요 없고, **의상 종류별 개수만 필요**.

---

## 💡 정답 풀이 방법

**알고리즘** : 조합론 (Combinatorics) + 경우의 수

**핵심 아이디어**:
```
1. Map으로 의상 종류별 개수 카운트
2. 각 종류별로 (개수 + 1)을 곱함 (안 입는 경우 포함)
3. 마지막에 1을 빼줌 (아무것도 안 입는 경우 제외)
```

---

## 🔑 핵심 개념

### 1️⃣ 왜 (개수 + 1)을 하는가?

각 의상 종류에서 "해당 종류의 옷을 안 입는 선택"도 고려해야 하기 때문!

**예시 입력**:
```
hat headgear
sunglasses eyewear
turban headgear
```

**Map에 저장된 정보**:

| 종류 | 개수 |
|------|------|
| headgear | 2 |
| eyewear | 1 |

**가능한 선택지**:
- `headgear`: {선택 X, hat, turban} → 총 **3가지** 선택지
- `eyewear`: {선택 X, sunglasses} → 총 **2가지** 선택지

**경우의 수 계산**:
```
(2 + 1) × (1 + 1) = 3 × 2 = 6
```

### 2️⃣ 왜 마지막에 -1을 하는가?

문제에서 "**최소 한 개 이상의 옷을 입어야 한다**"고 했으므로, **"아무것도 안 입는 경우(1가지)"를 빼줘야 함**.

```
6 - 1 = 5
```

**최종 답**: **5가지**

### 3️⃣ 경우의 수 계산 공식

```cpp
long long ret = 1;
for(auto c : mp)
    ret *= ((long long)c.second + 1);

ret--;  // 아무것도 안 입는 경우 제외
```

**공식**:
```
결과 = (의상1 개수 + 1) × (의상2 개수 + 1) × ... × (의상N 개수 + 1) - 1
```

---

## 📊 예제 분석

### 🎯 예제 입력
```
2
3
hat headgear
sunglasses eyewear
turban headgear
3
mask face
sunglasses face
makeup face
```

### 📌 첫 번째 테스트 케이스

**Map 상태**:
- headgear: 2개 (hat, turban)
- eyewear: 1개 (sunglasses)

**경우의 수**:
```
(2 + 1) × (1 + 1) - 1 = 3 × 2 - 1 = 6 - 1 = 5
```

**가능한 조합**:
1. hat
2. turban
3. sunglasses
4. hat / sunglasses
5. turban / sunglasses

### 📌 두 번째 테스트 케이스

**Map 상태**:
- face: 3개 (mask, sunglasses, makeup)

**경우의 수**:
```
(3 + 1) - 1 = 4 - 1 = 3
```

**가능한 조합**:
1. mask
2. sunglasses
3. makeup

---

## 🚨 주의사항

### 1️⃣ long long 사용

```cpp
❌ int ret = 1;  // 의상 개수가 많으면 오버플로우 가능!

✅ long long ret = 1;  // 안전하게 long long 사용
```

**이유**:
- 의상 종류 : 최대 30개
- 각 종류별 최대 개수 : 30개
- 최악의 경우: 31^30 → int 범위 초과!

### 2️⃣ Map 초기화

```cpp
while(N--)
{
    mp.clear();  // ✅ 매 테스트마다 초기화 필수!
    ...
}
```

테스트 케이스마다 독립적이므로 반드시 초기화해야 함!

### 3️⃣ 의상 이름은 불필요

```cpp
cin >> A >> B;  // A는 사용 안 함, B(종류)만 사용
mp[B]++;        // 종류별 개수만 카운트
```

---

## 🔑 핵심: map vs unordered_map

### ⚡ 왜 unordered_map을 사용하는가?

이 문제는 **정렬이 필요 없고**, **순서가 중요하지 않음**!
→ **해시 테이블(`unordered_map`)이 더 효율적**

<br>

### 📊 비교표

| 항목          | `map` | `unordered_map` ⚡ |
|-------------|-------|-------------------|
| **내부 구조**   | Red-Black Tree | **Hash Table** |
| **삽입/조회**   | O(log K) | **O(1)** 평균 |
| **정렬 여부**   | ✅ 정렬됨 | ❌ 정렬 안 됨 |
| **이 문제에서는** | 불필요한 정렬 | **최적** ⚡ |

<br>

### 💡 핵심 차이

**`map`의 동작**:
```
mp["headgear"]++

→ Red-Black Tree 탐색
→ 루트부터 logK번 비교
→ 삽입/수정
→ 트리 균형 유지 (회전)

⏱️ O(log K) = O(5) ≈ 5번 연산
```

**`unordered_map`의 동작**:
```
mp["headgear"]++

→ 해시 함수 계산
→ 해시값으로 직접 접근
→ 삽입/수정

⏱️ O(1) = 1번 연산
```

**→ 약 5배 빠름!**

---

## ⏱️ 시간복잡도 분석

### 📌 전체 시간복잡도: O(M)

**변수 정의**:
- M : 의상 개수 (최대 30)
- K : 의상 종류 개수 (최대 30)
- N : 테스트 케이스 수 (최대 100)

### 🔍 단계별 시간복잡도

#### 1️⃣ 의상 종류별 개수 카운트
```cpp
for(int i = 0; i < M; i++)
{
    cin >> A >> B;
    mp[B]++;  // unordered_map 삽입 - O(1) 평균
}
```

**시간복잡도**: **O(M)**

**이유**:
- M번 반복
- 각 반복마다 `mp[B]++` 연산: **O(1)** (해시 테이블)
- **M × 1 = O(M)**

<br>

#### 2️⃣ 경우의 수 계산
```cpp
long long ret = 1;
for(auto c : mp)
    ret *= ((long long)c.second + 1);
```

**시간복잡도**: **O(K)**

**이유**:
- K개 종류 순회: O(K)
- 각 종류마다 곱셈: O(1)

<br>

#### 3️⃣ 최종 시간복잡도

**테스트 케이스 1개**: O(M) + O(K) = **O(M + K) ≈ O(M)**

**전체 (N개 테스트 케이스)**: **O(N × M)**

<br>

### 🚀 성능 비교

**최악의 경우 (N=100, M=30, K=30)**:

| 자료구조 | 삽입 연산 | 실제 연산 횟수 | 비고 |
|---------|----------|---------------|------|
| `map` | O(M log K) | 100 × 30 × 5 = **15,000회** | 불필요한 정렬 |
| `unordered_map` | O(M) | 100 × 30 × 1 = **3,000회** | **5배 빠름** ⚡ |

**✅ 결과**: 3,000 << 100,000,000 (1억) → **여유롭게 통과!**

<br>

---

## 💾 공간복잡도 분석

### 📌 전체 공간복잡도: O(K)

**사용 메모리**:

```cpp
unordered_map<string, int> mp;  // 해시 테이블
```

- K개 종류 저장
- 각 엔트리: `<string, int>` + 해시 노드
- 약 50 bytes × 30 = **1.5 KB**

**✅ 결과**: 1.5 KB << 256 MB → **충분!**

<br>

---

## 🎯 효율성 요약

| 항목 | 값 |
|-----|-----|
| **시간복잡도** | O(M) ⚡ |
| **최악 연산 횟수** | 약 3,000회 |
| **공간복잡도** | O(K) |
| **최대 메모리** | 약 1.5 KB |

### ✅ 알고리즘 장점

- **최적 자료구조** : `unordered_map`으로 O(1) 삽입
- **수학 공식 활용** : 조합 생성 불필요
- **직관적 풀이** : 코드가 짧고 명확
- **효율적** : 시간/공간 모두 최적화

<br>

---

**⏱️ 시간복잡도**: O(M)

**💾 공간복잡도**: O(K)