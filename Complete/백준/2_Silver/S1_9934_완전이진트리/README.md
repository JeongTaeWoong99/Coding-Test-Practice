**📅 작성일**: 2025-10-16

## 🔗 문제 링크

[백준 9934번 - 완전 이진 트리](https://www.acmicpc.net/problem/9934)

**난이도**: Silver 1

---

## 🤔 접근법

깊이가 K인 완전 이진 트리를 **중위 순회(Inorder Traversal)** 한 결과가 주어진다.

이 순회 결과를 바탕으로 트리의 각 레벨별로 노드를 출력하는 문제이다.

**핵심은 중위 순회의 특성**을 이해하는 것!
- 중위 순회 : **왼쪽 서브트리 → 루트 → 오른쪽 서브트리** 순서
- 완전 이진 트리에서 배열의 **중앙값이 항상 루트 노드**가 됨

---

## 💡 정답 풀이 방법

**알고리즘** : 재귀 + 분할 정복 (Divide and Conquer)

**핵심 아이디어**:
```
1. 중위 순회 배열에서 중앙값을 찾아 현재 레벨에 추가
2. 중앙값을 기준으로 배열을 왼쪽/오른쪽 절반으로 분할
3. 왼쪽 절반은 왼쪽 서브트리 → 재귀 처리
4. 오른쪽 절반은 오른쪽 서브트리 → 재귀 처리
5. 각 레벨별로 저장된 노드들을 순서대로 출력
```

---

## 🔑 핵심 포인트

### 1️⃣ 중위 순회 특성 이해

```
완전 이진 트리 예시:
        3
       / \
      6   2
     / \ / \
    1  4 5  7

중위 순회 결과: [1, 6, 4, 3, 5, 2, 7]
                         ↑
                     중앙 = 루트!
```

**✅ 핵심**: 배열의 중앙값이 트리의 루트 노드
- 중앙값 왼쪽 = 왼쪽 서브트리의 중위 순회
- 중앙값 오른쪽 = 오른쪽 서브트리의 중위 순회

### 2️⃣ 범위 기반 재귀

```cpp
void go(int _start, int _end, int level)
{
    if(_start > _end) return;  // 범위가 유효하지 않으면 종료

    int _mid = (_start + _end) / 2;  // 중앙값 계산
    ret[level].push_back(a[_mid]);   // 현재 레벨에 추가

    go(_start, _mid - 1, level + 1); // 왼쪽 서브트리
    go(_mid + 1, _end, level + 1);   // 오른쪽 서브트리
}
```

**✅ 핵심**: 단일 인덱스가 아닌 **범위(start, end)** 전달
- 배열을 절반씩 나누면서 각 서브트리 처리
- 레벨이 내려갈수록 `level + 1`로 증가

### 3️⃣ _start == _end 예외 처리

```cpp
if(_start == _end)
{
    ret[level].push_back(a[_start]);
    return;
}
```

**✅ 핵심**: 범위가 단일 요소일 때 별도 처리
- 더 이상 분할할 수 없는 리프 노드
- 바로 추가하고 반환

### 4️⃣ pow() 함수로 노드 개수 계산

```cpp
int _end = (int)pow(2, n) - 1;
```

**✅ 핵심**: 깊이 n인 완전 이진 트리의 노드 개수 = `2^n - 1`
- `pow()` 함수는 double 반환 → `(int)` 캐스팅 필요
- 예: n=3 → 2³-1 = 7개 노드

---

## 📊 재귀 동작 상세 분석

### 🎯 입력
```
3
1 6 4 3 5 2 7
```

### 🔍 재귀 트리 전개

```
go(0, 6, 1):  mid=3 → a[3]=3 → ret[1]={3}
  │
  ├─ go(0, 2, 2):  mid=1 → a[1]=6 → ret[2]={3, 6}
  │   │
  │   ├─ go(0, 0, 3):  start==end → a[0]=1 → ret[3]={3, 6, 1}
  │   │
  │   └─ go(2, 2, 3):  start==end → a[2]=4 → ret[3]={3, 6, 1, 4}
  │
  └─ go(4, 6, 2):  mid=5 → a[5]=2 → ret[2]={3, 6, 2}
      │
      ├─ go(4, 4, 3):  start==end → a[4]=5 → ret[3]={3, 6, 1, 4, 5}
      │
      └─ go(6, 6, 3):  start==end → a[6]=7 → ret[3]={3, 6, 1, 4, 5, 7}
```

### 📋 최종 결과

```
ret[1] = {3}
ret[2] = {6, 2}
ret[3] = {1, 4, 5, 7}
```

**출력:**
```
3
6 2
1 4 5 7
```

**✅ 핵심 원리**:
- 매 레벨마다 배열을 절반씩 나눔
- 중앙값을 루트로 선택
- 재귀적으로 같은 방식 반복

---

## ⏱️ 시간복잡도

**O(N)** (N = 노드 개수 = 2^K - 1)

**분석**:
- 모든 노드를 정확히 한 번씩 방문
- 각 노드에서 수행하는 연산: 중앙값 계산 + 벡터 추가 → O(1)
- 총 시간: N개 노드 × O(1) = **O(N)**

**예시**:
```
K = 3 → N = 7 → 7번 재귀 호출
K = 10 → N = 1023 → 1023번 재귀 호출
```

---

## 💾 공간복잡도

**O(N + K)**

**분석**:
- `a[1030]`: 중위 순회 배열 → O(N)
- `ret[14]`: 레벨별 벡터 배열 → O(N) (모든 레벨 합치면 N개 노드)
- 재귀 스택: 최대 깊이 K → O(K)

**총 공간**: O(N + K) ≈ **O(N)** (K ≤ log N이므로)

---

**⏱️ 시간복잡도**: O(N) - 모든 노드를 한 번씩 방문

**💾 공간복잡도**: O(N + K) - 배열 저장 + 재귀 스택
