// 백준 3197 - 백조의 호수
// 난이도: Platinum 5
//
// 배열 R C (1 ≤ R, C ≤ 1500)
// . = 물
// X = 빙판
// L = 백조 위치 (2개)
//
// 알고리즘:
// 1. 두 개의 BFS 사용 : 백조 이동 BFS + 물 녹이기 BFS
// 2. 백조가 물을 따라 이동하다 빙판을 만나면 다음 날 탐색할 위치로 저장
// 3. 물이 빙판과 인접하면 녹여서 물로 만듦
// 4. 매일 반복하며 백조가 만날 때까지 진행

#include <bits/stdc++.h>
using namespace std;

int                  R, C;                      // 맵 크기
int                  swanY, swanX;              // 첫 번째 백조 위치
int                  day = 0;                   // 경과 일수
char                 a[1504][1504];             // 맵 정보
int                  visitedSwan[1504][1504];   // 백조 방문 체크
int                  visitedWater[1504][1504];  // 물 방문 체크
string               tempS;
queue<pair<int,int>> waterQ, waterTempQ;        // 물 녹이기용 큐 (현재, 다음날)
queue<pair<int,int>> swanQ,  swanTempQ;         // 백조 탐색용 큐 (현재, 다음날)
int                  dy[4] = {-1, 1, 0, 0};     // 상하좌우 이동
int                  dx[4] = {0, 0, -1, 1};

// 큐 초기화 함수
void ClearQ(queue<pair<int,int>> &q)
{
    queue<pair<int,int>> empty;
    swap(q, empty);
}

// 물에 인접한 빙판을 녹이는 함수(= BFS 구조 동일)
void WaterMelting()
{
    while (!waterQ.empty())
    {
        int y = waterQ.front().first;
        int x = waterQ.front().second;
        waterQ.pop();

        for (int i = 0; i < 4; i++)
        {
            int ny = y + dy[i];
            int nx = x + dx[i];

            // 범위 체크 및 방문 체크
            if (ny < 0 || ny >= R || nx < 0 || nx >= C || visitedWater[ny][nx]) continue;

            // 빙판을 만나면 녹여서 물로 만듦
            if (a[ny][nx] == 'X')
            {
                visitedWater[ny][nx] = 1;
                waterTempQ.emplace(ny, nx); // 다음날 waterTempQ에 저장
                a[ny][nx] = '.';
            }
        }
    }
}

// 백조가 다른 백조를 찾을 수 있는지 BFS로 탐색(= BFS 구조 동일)
bool Move()
{
    while (!swanQ.empty())
    {
        int y = swanQ.front().first;
        int x = swanQ.front().second;
        swanQ.pop();

        for (int i = 0; i < 4; i++)
        {
            int ny = y + dy[i];
            int nx = x + dx[i];

            // 범위 체크 및 방문 체크
            if (ny < 0 || ny >= R || nx < 0 || nx >= C || visitedSwan[ny][nx]) continue;

            visitedSwan[ny][nx] = 1;

            // 물인 경우 => 계속 탐색
            if (a[ny][nx] == '.')
            {
                swanQ.emplace(ny, nx);
            }
            // 빙판인 경우 => 다음 날 탐색할 위치로 저장(다음날 swanTempQ에 저장)
            else if (a[ny][nx] == 'X')
            {
                swanTempQ.emplace(ny, nx);
            }
            // 다른 백조를 찾음!
            else if (a[ny][nx] == 'L')
            {
                return true;
            }
        }
    }

    return false;
}

int main()
{
    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    // 입력 처리(가로 세로 입력 상관없음 => 어짜피 탐색과 결과는 동일하기 때문...)
    cin >> R >> C;

    for (int i = 0; i < R; i++)
    {
        cin >> tempS;

        for (int j = 0; j < C; j++)
        {
            a[i][j] = tempS[j];

            // 백조 위치 저장 (마지막 백조 위치를 시작점으로. 'L'위치 둘 중 하나 사용하면 됨.)
            if (a[i][j] == 'L')
            {
                swanY = i;
                swanX = j;
            }

            // 물이나 백조 위치를 물 확장 큐에 추가
            if (a[i][j] == '.' || a[i][j] == 'L')
            {
                visitedWater[i][j] = 1;      // 방문 체크(중복 방문 방지)
                waterQ.emplace(i, j); // 큐에 넣어 놓고, 주변 방문 안한, 빙판만 체크하면 됨
            }
        }
    }

    // 백조 BFS 시작 위치 설정
    swanQ.emplace(swanY, swanX);
    visitedSwan[swanY][swanX] = 1;

    // 백조가 만날 때까지 반복
    while (true)
    {
        // 1. 백조 BFS로 다른 백조 찾기(찾으면 TRUE, 못찾으면, FALSE)
        if (Move()) break;

        // 2. 물에 인접한 빙판 녹이기
        WaterMelting();

        // 3. 다음 날 탐색 준비
        waterQ = waterTempQ;
        swanQ  = swanTempQ;
        ClearQ(waterTempQ);
        ClearQ(swanTempQ);

        // 날짜 증가
        day++;
    }

    // 결과 출력
    cout << day << "\n";

    return 0;
}