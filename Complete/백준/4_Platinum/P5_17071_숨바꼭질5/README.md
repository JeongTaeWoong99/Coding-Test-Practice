**📅 작성일**: 2025-10-07

## 🔗 문제 링크
[백준 17071번 - 숨바꼭질 5](https://www.acmicpc.net/problem/17071)

---

## 🤔 접근법

풀이 아이디어가 생각나지 않아, 구현 실패. 추후, 다시 도전 예정.

숨바꼭질 시리즈의 최고난이도 문제.

동생이 가속도로 이동하는 특이한 패턴 때문에 일반 BFS로는 해결 불가.

**핵심은 홀짝으로 체크하는 것!**

수빈이가 먼저 2초에 방문했는데, 동생이 4초에 방문하면, 수빈이는 왔다갔다하며 4초에도 그 위치에 있을 수 있다.

➡️ 2초에 먼저 도착 했다면, **4초**에 만날 수 있음!

---

## 💡 정답 풀이 방법

**알고리즘**: BFS + 플러드필(Flood Fill) + 홀짝 구분 방문 처리

**핵심 아이디어**:
```
1. visited를 2차원 배열로 구성: visited[홀짝][위치]
2. 플러드필 알고리즘으로 수빈이가 도달 가능한 모든 위치를 "색칠"
3. 매 턴마다 동생과 수빈이가 함께 이동하면서 체크
4. 동생의 위치를 수빈이가 같은 홀짝 턴에 방문했다면 만남 가능
```

**시간 복잡도**: O(N)
- 각 위치를 홀수/짝수 턴에 최대 1번씩만 방문
- 최대 500,000 × 2 = 1,000,000번 방문

**공간 복잡도**: O(N)
- visited[2][500,004] 배열

---

## 🔑 주요 구현 포인트

### 1️⃣ 홀짝 구분 visited 배열
```cpp
int visited[2][MAX + 4];  // [홀짝][위치]
```

**왜 홀짝을 구분해야 하는가?**
- 수빈이는 ±1 이동으로 같은 자리를 왔다갔다 할 수 있음
- 위치 X에 2초(짝수)에 도착했다면, 4초, 6초, 8초... 모든 짝수 초에 그 위치에 있을 수 있음
- 위치 X에 3초(홀수)에 도착했다면, 5초, 7초, 9초... 모든 홀수 초에 그 위치에 있을 수 있음

**예시:**
```
수빈이가 위치 15에 2초에 도착:
  15 -> 16 -> 15 -> 16 -> 15 (2초, 4초, 6초...)
  ➡️ visited[0][15] = 1 (짝수 턴에 15 방문 가능)

동생이 위치 15에 4초에 도착:
  5 -> 6 -> 8 -> 11 -> 15 (0, 1, 2, 3, 4초)
  ➡️ 4초는 짝수 턴!

if(visited[4 % 2][15])  // visited[0][15] = 1
  ➡️ 만남 성공! 답은 4초
```

### 2️⃣ 플러드필 알고리즘 (Flood Fill)
```cpp
// 매 턴마다 수빈이가 도달 가능한 모든 위치를 "색칠"
int qSize = q.size();  // 현재 턴의 모든 위치 처리
for(int i = 0; i < qSize; i++)
{
    int x = q.front();
    q.pop();

    for(int nx : {x + 1, x - 1, x * 2})
    {
        if(nx < 0 || nx > MAX || visited[turn % 2][nx]) continue;

        visited[turn % 2][nx] = 1;  // "색칠"
        q.push(nx);
    }
}
```

**플러드필의 의미:**
- 그림판의 "페인트 채우기"와 같은 개념
- 수빈이가 도달 가능한 모든 위치를 한 턴에 모두 "색칠"
- 50만개의 위치를 홀짝으로 나눠서 색칠하면 효율적!

### 3️⃣ 동생과 수빈이가 함께 이동
```cpp
while(!q.empty())
{
    M += turn;  // 동생 먼저 이동 (1, 2, 3, 4...)

    if(M > MAX) break;

    // 핵심! 동생의 위치를 수빈이가 같은 홀짝 턴에 방문했는지 체크
    if(visited[turn % 2][M])
    {
        match = true;
        break;
    }

    // 수빈이 이동 (플러드필)
    // ...

    turn++;  // 다음 턴
}
```

**왜 함께 이동하는가?**
- 동생의 이동은 예측 가능 (1, 2, 3, 4... 씩 증가)
- 수빈이의 이동은 BFS로 모든 경로 탐색
- 매 턴마다 둘 다 이동시키면서 만나는 시점 체크

### 4️⃣ 동생의 특별한 이동 패턴
```cpp
M += turn;  // 동생은 매 턴 turn만큼 이동
```

**동생의 위치 계산:**
```
턴 0: M
턴 1: M + 1
턴 2: M + 1 + 2 = M + 3
턴 3: M + 1 + 2 + 3 = M + 6
턴 4: M + 1 + 2 + 3 + 4 = M + 10

공식: n초 후 동생 위치 = M + n*(n+1)/2
```

---

## 📊 예시 실행 흐름

**입력**: `N = 17, M = 5`

```
턴 0 (초기화):
  수빈이: 위치 17, visited[0][17] = 1
  동생:   위치 5

턴 1:
  동생: 5 + 1 = 6
  수빈이: 17에서 16, 18, 34로 이동
    ➡️ visited[1][16] = visited[1][18] = visited[1][34] = 1
  만남 체크: visited[1][6] == 0 ➡️ 못 만남

턴 2:
  동생: 6 + 2 = 8
  수빈이: 16, 18, 34에서 15, 17, 19, 32, 33, 35, 36, 68로 이동
    ➡️ visited[0][15] = visited[0][17] = ... = 1
  만남 체크: visited[0][8] == 0 ➡️ 못 만남

턴 3:
  동생: 8 + 3 = 11
  수빈이: 이전 위치들에서 이동...
  만남 체크: visited[1][11] == 0 ➡️ 못 만남

턴 4:
  동생: 11 + 4 = 15
  만남 체크: visited[0][15] == 1 ➡️ 만남 성공! ✅

출력: 4
```

**왜 4초에 만날까?**
- 수빈이는 2초(짝수 턴)에 위치 15를 방문
- 그 후 15 ↔ 16 왔다갔다 가능
- 4초(짝수 턴)에도 위치 15에 있을 수 있음!
- 동생은 4초에 위치 15 도착
- ➡️ 4초에 만남!

---

## 🚨 주의사항

1. **홀짝 구분은 필수** : visited[2]로 홀수/짝수 턴 분리
2. **동생 이동 먼저** : 매 턴 시작에 동생을 먼저 이동시킨 후 체크
3. **레벨별 BFS** : `qSize = q.size()`로 현재 턴의 모든 위치 처리
4. **범위 초과 체크** : 동생이 500,000 초과하면 만날 수 없음
5. **초기값 처리** : `visited[0][N] = 1`로 시작 (0번 턴은 짝수)

---

## 💡 핵심 요약

**이 문제의 핵심은 3가지:**

1️⃣ **홀짝으로 체크** : 수빈이가 2초에 방문했어도 4초에 만날 수 있음!

2️⃣ **플러드필 알고리즘** : 50만개 위치를 홀짝으로 나눠서 색칠하면 효율적!

3️⃣ **동생과 수빈이가 함께 이동** : 매 턴마다 둘 다 이동시키면서 체크!

**답은 처음 만난 시점이 아니라, 같은 홀짝 턴에 만나는 시점!**