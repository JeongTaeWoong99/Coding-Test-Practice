**📅 작성일**: 2025-10-17

## 🔗 문제 링크

[백준 15684번 - 사다리 조작](https://www.acmicpc.net/problem/15684)

**난이도**: Gold 3

---

## 🤔 접근법

(문제가 이해가 안됨. 추후 다시 풀어볼 예정)

(N / M / H의 순서를 세로선 / 세팅 연결선 / 가로선 이렇게 배치를 해놓음;;)

사다리 게임에서 i번 세로선의 결과가 i번이 나오도록 만들기 위해 추가해야 하는 가로선 개수의 최솟값을 구하는 문제.

**핵심은 백트래킹**으로 가로선을 추가하면서, 조건을 만족하는 최소 개수를 찾는 것!

문제에서 **3개 이하**로 제한을 두었기 때문에 백트래킹으로 충분히 해결 가능하다.

---

## 💡 정답 풀이 방법

**알고리즘** : 백트래킹 (Backtracking)

**핵심 아이디어**:
```
1. 백트래킹으로 가로선을 추가할 수 있는 모든 위치를 탐색
2. 가로선 추가 후 Check() 함수로 조건을 만족하는지 확인
3. 조건을 만족하면 최솟값 갱신
4. 가로선을 제거하고 다음 위치 탐색 (백트래킹)
5. 최대 3개까지만 추가 (문제 제한)
```

---

## 🔑 핵심 포인트

### 1️⃣ INF(무한대) 사용 이유

```cpp
const int INF = 987654321;  // 불가능한 경우를 나타내는 무한대 값
int minRet = INF;           // 추가해야 하는 가로선의 최소 개수
```

**✅ 핵심** : 최솟값을 구하는 문제는 **최대값에서 최소로 줄여가는 방식**

**왜 INF를 사용하는가?**
- 최솟값 갱신을 위해 초기값을 충분히 큰 값으로 설정
- `minRet`을 0으로 초기화하면 `min(minRet, count)` 비교가 불가능
- INF로 설정하여 첫 번째 유효한 값이 무조건 갱신되도록 함
- 마지막에 `minRet == INF`이면 불가능한 경우 → -1 출력

**💡 int 최대값을 사용하지 않는 이유**:
- `INT_MAX` (약 21억)는 너무 크고 오버플로우 위험
- 987654321은 충분히 크면서도 안전한 값 (코딩테스트 관례)

### 2️⃣ 가지치기

```cpp
if(count > 3 || count >= minRet) return;
```

**✅ 핵심**: 불필요한 탐색을 조기에 차단

**두 가지 조건**:
1. `count > 3`: 문제에서 3개 초과는 -1 출력하므로 탐색 불필요
2. `count >= minRet`: 이미 찾은 최솟값 이상이면 더 이상 최소가 될 수 없음

### 3️⃣ 가로선 연속 배치 방지

```cpp
if(visited[i][j] || visited[i][j - 1] || visited[i][j + 1]) continue;
```

**✅ 핵심**: 사다리 게임 규칙상 가로선이 연속으로 놓일 수 없음

**세 가지 조건**:
1. `visited[i][j]`: 현재 위치에 이미 가로선이 있음
2. `visited[i][j - 1]`: 왼쪽에 가로선이 있음 (j번 세로선이 이미 왼쪽과 연결)
3. `visited[i][j + 1]`: 오른쪽에 가로선이 있음 (j+1번 세로선이 이미 오른쪽과 연결)

### 4️⃣ Check() 함수 - 사다리 타기 시뮬레이션

```cpp
for(int i = 1; i <= N; i++)
{
    int currentPos = i;  // i번 세로선에서 시작

    for(int j = 1; j <= H; j++)
    {
        if(visited[j][currentPos])           // 오른쪽으로 이동
            currentPos++;
        else if(visited[j][currentPos - 1])  // 왼쪽으로 이동
            currentPos--;
    }

    if(currentPos != i) return false;  // i번에서 시작해서 i번으로 끝나야 함
}
```

**✅ 핵심**: 모든 세로선에 대해 i → i가 되는지 검증

### 5️⃣ 백트래킹 패턴

```cpp
visited[i][j] = 1;       // 가로선 추가
Back(i, count + 1);      // 재귀 호출
visited[i][j] = 0;       // 백트래킹 (원상복구)
```

**✅ 핵심**: 재귀 반환 후 `visited[i][j] = 0`으로 원상복구
- 다른 경로에서 해당 위치를 다시 사용할 수 있도록 함
- 이것이 **백트래킹의 핵심**!

## ⏱️ 시간복잡도

**이론적 분석**: **O(C(H×(N-1), 3) × N×H)**

**분석**:
- 가로선을 놓을 수 있는 위치: `H × (N-1)` 개
- 그 중 최대 3개 선택: `C(H×(N-1), 3)`
- 각 선택마다 Check() 함수 호출: `O(N×H)`

**최악의 경우 계산** (N=10, H=30):
- 위치 개수: 30 × 9 = 270
- C(270, 3) = 270 × 269 × 268 / 6 ≈ 3,270,000
- Check() 비용: 10 × 30 = 300
- 총 연산: 3,270,000 × 300 ≈ 9억

**하지만 실제로는 약 450만 정도!**

**왜 실제 연산이 훨씬 적은가?**
1. **가지치기 1**: `count > 3` → 3개 초과 시 즉시 종료
2. **가지치기 2**: `count >= minRet` → 이미 찾은 최솟값 이상이면 종료
3. **가로선 연속 배치 불가**: 많은 조합이 조기에 제거됨
4. **조건 만족 시 즉시 반환**: 최솟값 갱신 후 해당 브랜치 종료

**💡 백트래킹으로 풀 수 있는 이유**:
- 원래 이 문제는 일반적인 백트래킹으로는 시간 초과
- **하지만 3개 이하라는 제한** 덕분에 탐색 공간이 폭발적으로 감소
- 3개 제한이 없었다면 지수 시간 복잡도로 불가능
- **문제의 제약 조건을 활용한 최적화가 핵심!**

---

## 💾 공간복잡도

**O(H×N)**
- `visited[34][34]`: 가로선 상태 배열
- 재귀 스택: O(3) ≈ O(1) (최대 3개까지만 추가)

---

**⏱️ 시간복잡도**: O(C(H×(N-1), 3) × N×H) ≈ 약 450만 (실제)

**💾 공간복잡도**: O(H×N)
