#include <bits/stdc++.h>
using namespace std;

// 전역 변수 선언
const int INF = 987654321;  // 불가능한 경우를 나타내는 무한대 값
int       N, M, H;          // N = 세로선 개수, M = 이미 놓여진 가로선 개수, H = 가로선을 놓을 수 있는 위치 개수
int       A, B;             // 입력받는 가로선 정보 (A번 위치, B번 세로선)
int       minRet = INF;     // 추가해야 하는 가로선의 최소 개수
int       visited[34][34];  // 가로선이 놓여있는지 체크 (visited[i][j] = i번 위치에서 j번 세로선과 j+1번 세로선을 연결)

// i번 세로선의 결과가 i번이 나오는지 확인하는 함수
bool Check()
{
    // 모든 세로선(1~N)에 대해 검사
    for(int i = 1; i <= N; i++)
    {
        int currentPos = i;  // i번 세로선에서 시작

        // 위에서 아래로 내려가면서 가로선을 따라 이동
        for(int j = 1; j <= H; j++)
        {
            if(visited[j][currentPos])           // 현재 위치(j)에서 오른쪽으로 가는 가로선이 있으면
                currentPos++;                    // 오른쪽 세로선으로 이동
            else if(visited[j][currentPos - 1])  // 현재 위치(j)에서 왼쪽에서 오는 가로선이 있으면
                currentPos--;                    // 왼쪽 세로선으로 이동
        }

        // i번 세로선에서 시작했는데 i번이 아닌 다른 번호가 나오면 실패
        if(currentPos != i)
            return false;
    }

    // 모든 세로선이 자기 자신으로 돌아오면 성공
    return true;
}

// 백트래킹으로 가로선을 추가하는 함수
// here : 현재 탐색 중인 가로선 위치 (1~H)
// count : 현재까지 추가한 가로선 개수
void Back(int here, int count)
{
    // 가지치기 : 3개 초과로 추가하거나(문제 제한), 이미 찾은 최솟값 이상이면 종료
    if(count > 3 || count >= minRet) return;

    // 현재 상태에서 조건을 만족하면 최솟값 갱신
    if(Check())
    {
        minRet = min(minRet, count);
        return;
    }

    // 가로선을 추가할 수 있는 모든 위치 탐색
    for(int i = here; i <= H; i++)     // 세로 방향 (위에서 아래로)
    {
        for(int j = 1; j < N; j++)     // 가로 방향 (j번 세로선과 j+1번 세로선 연결)
        {
            // 가로선을 놓을 수 없는 경우들
            // 1. 이미 가로선이 있거나
            // 2. 왼쪽에 연결된 가로선이 있거나 (연속으로 놓을 수 없음)
            // 3. 오른쪽에 연결된 가로선이 있으면 (연속으로 놓을 수 없음)
            if(visited[i][j] || visited[i][j - 1] || visited[i][j + 1]) continue;
            
            visited[i][j] = 1;       // 가로선 추가
            Back(i, count + 1);      // 다음 가로선 추가 시도
            visited[i][j] = 0;       // 백트래킹 (원상복구)
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);

    // 입력 처리
    cin >> N >> M >> H;

    // 이미 놓여진 가로선 정보 입력
    for(int i = 0; i < M; i++)
    {
        cin >> A >> B;
        visited[A][B] = 1;  // A번 위치에서 B번 세로선과 B+1번 세로선을 연결
    }

    // 0개부터 시작해서 최소 개수 찾기
    Back(1, 0);

    // 결과 출력 (불가능하면 -1, 가능하면 최소 개수)
    cout << ((minRet == INF) ? -1 : minRet) << "\n";

    return 0;
}
