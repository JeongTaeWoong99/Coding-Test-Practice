**📅 작성일**: 2025-10-13

## 🔗 문제 링크

[백준 1987번 - 알파벳](https://www.acmicpc.net/problem/1987)

**난이도**: Gold 4

---

## 🤔 접근법


좌측 상단(0,0)에서 시작하여 상하좌우로 이동하면서, 지금까지 지나온 알파벳과 중복되지 않는 칸으로만 이동할 수 있다.

최대 몇 칸까지 이동할 수 있는지를 구하는 문제이다.

DFS + 백트래킹으로 모든 가능한 경로를 탐색하면서 최대 이동 칸 수를 구해야 한다.

핵심은 **알파벳 중복 체크 배열**을 사용하여 현재 경로에서 사용한 알파벳을 추적하는 것!

---

## 💡 정답 풀이 방법

**알고리즘** : DFS (깊이 우선 탐색) + 백트래킹

**핵심 아이디어**:
```
1. 알파벳 방문 체크 배열 (alpaVisited[26]) 사용
2. 4방향 탐색하면서 방문하지 않은 알파벳인 경우에만 이동
3. 이동 후 재귀 호출로 DFS 진행
4. 재귀 반환 시 방문 해제 (백트래킹)
5. 매 재귀마다 최대 이동 칸 수 갱신
```

**시간 복잡도**: O(4^L)
- L = 최대 경로 길이 (최대 26, 알파벳 개수)
- 각 칸에서 최대 4방향 탐색
- 실제로는 중복 체크와 맵 크기 제한으로 훨씬 적게 탐색

**공간 복잡도**: O(R×C + 26)
- 보드 배열: O(R×C)
- 알파벳 방문 배열: O(26)
- 재귀 스택: O(최대 경로 길이) ≈ O(26)

---

## 🔑 핵심 포인트

### 1️⃣ 알파벳을 인덱스로 변환

```cpp
int next = a[ny][nx] - 'A';  // 'A' = 0, 'B' = 1, ..., 'Z' = 25
```

**✅ 핵심**:
- `char` 타입의 알파벳을 배열 인덱스로 사용
- `'A'`를 빼면 0~25 범위의 정수로 변환
- 암묵적 형변환(Implicit Conversion)으로 자동 변환됨

**💡 명시적 캐스팅 vs 암묵적 변환**:
```cpp
// 모두 동일하게 동작
int next = a[ny][nx] - 'A';                    // ✅ 암묵적 변환 (권장)
int next = (int)a[ny][nx] - 'A';               // C 스타일 캐스팅
int next = static_cast<int>(a[ny][nx]) - 'A';  // C++ 스타일 캐스팅
```
- `char` 연산 시 **자동으로 int로 승격(promotion)** 됨 (C++ 표준)
- 코딩테스트에서는 간결함을 위해 명시적 캐스팅 생략 가능

### 2️⃣ 백트래킹 패턴

```cpp
if(alpaVisited[next] == 0)
{
    alpaVisited[next] = 1;      // 방문 처리
    DFS(ny, nx, cnt + 1);       // 재귀 호출
    alpaVisited[next] = 0;      // 백트래킹: 방문 해제 ⭐
}
```

**✅ 핵심**: 재귀 반환 후 `alpaVisited[next] = 0`으로 방문 해제
- 다른 경로에서 해당 알파벳을 다시 사용할 수 있도록 함
- 이것이 **백트래킹의 핵심**!

### 3️⃣ 최대값 갱신 타이밍

```cpp
void DFS(int y, int x, int cnt)
{
    ret = max(ret, cnt);  // ⭐ 함수 진입 시 바로 갱신

    // 4방향 탐색...
}
```

**✅ 핵심**: 함수 진입 시점에 바로 최대값 갱신
- 더 이상 이동할 수 없는 경우(리프 노드)에도 자동으로 처리됨
- 별도의 종료 조건 체크 불필요

### 4️⃣ 전역 변수 활용

```cpp
int  ret;             // 최대 이동 칸 수 (최대 결과값)
int  ny, nx;          // 다음 탐색할 좌표
int  alpaVisited[26]; // 알파벳 방문 체크 배열
```

**✅ 핵심**: 코딩테스트에서는 전역 변수로 간결하게 구현
- 함수 간 데이터 전달 간소화
- 빠른 구현이 목표

---

## 📊 예시 실행 흐름

**입력 예시**:
```
2 4
CAAB
ADCB
```

**보드 상태**:
```
C A A B
A D C B
```

**탐색 과정**:
```
1. (0,0) C 시작 → alpaVisited['C'] = 1, cnt = 1
2. (0,1) A 이동 → alpaVisited['A'] = 1, cnt = 2
3. (1,1) D 이동 → alpaVisited['D'] = 1, cnt = 3
4. (1,2) C 이동 시도 → 이미 방문(alpaVisited['C'] = 1) → 불가
5. 백트래킹하여 다른 경로 탐색...
```

**출력**: `3` (C → A → D → B 경로)

---

## ⏱️ 시간복잡도

**O(4^L)** (L = 최대 경로 길이, 최대 26)
- 이론적으로는 지수 시간이지만, 실제로는:
  - 알파벳 중복 체크로 대부분의 경로가 조기에 차단됨
  - 맵 크기 제한 (최대 20×20 = 400칸)
  - 실제 실행 시간은 충분히 빠름

---

## 💾 공간복잡도

**O(R×C + 26)**
- `a[21][21]`: 보드 배열 (최대 441칸)
- `alpaVisited[26]`: 알파벳 방문 체크 배열
- 재귀 스택: O(최대 경로 길이) ≈ O(26)
