**📅 작성일**: 2025-10-03

## 🔗 문제 링크
[백준 12851번 - 숨바꼭질 2](https://www.acmicpc.net/problem/12051)

---

## 🤔 접근법

3가지 경우에 대해서, 배열을 통해서, 해결해 보려고 함.

하지만, BFS 응용에서 막힘.

BFS 문제로, 최단 시간을 구하는 것은 기본적인 BFS로 해결 가능하다.

하지만 이 문제는 **최단 시간으로 도달하는 방법의 수**까지 구해야 한다.

핵심은 **같은 시간에 도달하는 다른 경로들을 모두 카운트**하는 것!

---

## 💡 정답 풀이 방법

**알고리즘**: BFS + 경로 수 카운팅

**핵심 아이디어**:
```
1. visited 배열을 1-based로 사용 (0 = 미방문, 1 이상 = 방문 시간)
2. pathNum 배열로 각 위치까지 도달하는 방법의 수 추적
3. 처음 방문: pathNum[next] = pathNum[now] (경로 갱신)
4. 같은 시간 재방문: pathNum[next] += pathNum[now] (경로 누적)
```

**시간 복잡도**: O(N + K)
- BFS는 각 위치를 최대 1번씩만 방문
- N, K ≤ 100,000이지만 순간이동으로 인해 MAX = 200,000 설정

**공간 복잡도**: O(MAX)
- visited, pathNum 배열

---

## 🔑 핵심 포인트

### 1️⃣ visited 배열의 1-based 트릭
```cpp
visited[N] = 1;  // 시작점은 시간 1로 설정 (0은 미방문 표시용)
```
- `0`: 미방문
- `1 이상`: 방문 완료 + 도달 시간 저장

### 2️⃣ 경로 수 카운팅 로직
```cpp
// 처음 방문하는 경우
if (!visited[next])
{
    visited[next] = visited[now] + 1;  // 최소 시간 갱신
    pathNum[next] = pathNum[now];      // 경로 갱신 (=)
}
// 같은 시간에 도달하는 다른 경로
else if (visited[next] == visited[now] + 1)
{
    pathNum[next] += pathNum[now];     // 경로 수 누적 (+=)
}
```

**왜 `=`와 `+=`를 구분하는가?**
- **처음 방문**: 이전 경로 수를 그대로 복사 (`=`)
- **같은 시간 재방문**: 다른 경로가 추가되므로 누적 (`+=`)

### 3️⃣ MAX = 200,000 설정 이유
```cpp
const int MAX = 200000;  // 100,000이 아닌 이유?
```
- 문제 범위: 0 ≤ N, K ≤ 100,000
- 하지만 순간이동(X * 2)으로 100,000을 초과할 수 있음
- 예: K를 지나쳐서 돌아오는 경로가 최단일 수 있음
- 안전하게 2배로 설정

### 4️⃣ Range-based for loop
```cpp
for (int next : {now - 1, now + 1, now * 2})
```
- C++11 초기화 리스트를 사용한 반복문
- 3가지 이동(X-1, X+1, X*2)을 차례로 순회
- 깔끔하고 직관적인 코드

---

## 📊 예시 실행 흐름

**입력**: `N = 5, K = 17`

```
초기: visited[5] = 1, pathNum[5] = 1

BFS 진행:
┌─────────┬──────────┬──────────┐
│ 위치    │ visited  │ pathNum  │
├─────────┼──────────┼──────────┤
│ 5       │ 1        │ 1        │
│ 4       │ 2        │ 1        │
│ 6       │ 2        │ 1        │
│ 10      │ 2        │ 1        │
│ 7       │ 3        │ 2 ⭐     │
│ 8       │ 3        │ 1        │
│ ...     │ ...      │ ...      │
│ 17      │ ?        │ ?        │
└─────────┴──────────┴──────────┘

출력:
  visited[17] - 1  ← 최소 시간
  pathNum[17]      ← 방법의 수
```

---

## 🚨 주의사항

1. **visited는 1-based**: 0이 미방문 표시이므로 시작점을 1로 설정
2. **출력 시 -1 보정**: `visited[K] - 1`로 실제 시간 계산
3. **pathNum은 long long**: 경로 수가 매우 커질 수 있음
4. **범위 체크 필수**: `0 <= next && next <= MAX`