**📅 작성일**: 2025-10-18

## 🔗 문제 링크
[백준 1016번 - 제곱 ㄴㄴ 수](https://www.acmicpc.net/problem/1016)

[문제 해설 - 유튜브](https://www.youtube.com/watch?v=l9jU0Is7kek)

---

## 🤔 접근법

(응용이 많이 들어간 문제라 문제 이해가 되지 않았다. 추후, 다시 풀어볼 예정.)

제곱수로 나누어떨어지지 않는 수의 개수를 구하는 문제.

범위가 min ≤ 10^12로 엄청나게 크기 때문에, 모든 수를 일일이 체크할 수 없다.

하지만 **범위의 길이**는 최대 10^6이므로, 에라토스테네스의 체를 응용할 수 있다!

핵심은 **절대값이 아닌 상대 위치**를 인덱스로 사용하는 것.

---

## 💡 정답 풀이 방법

**알고리즘** : 에라토스테네스의 체 응용 (Sieve of Eratosthenes Variant)

**핵심 아이디어**:
```
1. start~end 범위를 0~(end-start) 배열로 매핑 (상대 위치 활용)
2. 2^2, 3^2, 4^2, ... 각 제곱수의 배수들을 false로 마킹
3. true로 남아있는 개수가 제곱ㄴㄴ수의 개수
```

**시간 복잡도** : O(√end × (end-start))

**왜 이렇게 계산되는가?**
- **외부 루프** : `base = 2 ~ √end` → 최대 √end번 반복
  - 예: end = 10^12이면 √end = 10^6번
- **내부 루프** : 각 제곱수의 배수를 마킹
  - `idx = firstIdx; idx < sieve.size(); idx += square`
  - sieve.size() = `(end - start + 1)` → 최대 10^6개
  - 각 base마다 최대 (end - start) 범위를 탐색
- **결합** : √end × (end-start) → 최대 10^6 × 10^6 = 10^12

**왜 (end-start)인가?**
- sieve 배열의 크기가 (end - start + 1)이기 때문
- 우리는 start부터 end까지의 **범위 길이**만큼만 체크
- 절대값이 아닌 **상대 범위**를 사용하므로 범위 길이가 핵심!

**공간 복잡도** : O(end - start)
- sieve 배열 크기 : `end - start + 1` (최대 10^6)

---

## 🔑 핵심 포인트

### 1️⃣ 상대 인덱스 매핑

**❌ 불가능한 접근** : 절대값 사용
```cpp
// start = 1,000,000,000,000일 때 배열 크기 1조? → 메모리 초과!
vector<bool> sieve(end + 1);  // ❌
```

**✅ 정답 접근** : 상대 위치 사용
```cpp
// 범위 길이만큼만 배열 생성 (최대 100만)
vector<bool> sieve(end - start + 1);  // ✅

// sieve[0]  → 실제 값 start
// sieve[1]  → 실제 값 start+1
// sieve[i]  → 실제 값 start+i
```

**왜 +1을 해주는가?**
- start부터 end까지 **양 끝을 포함**해야 하기 때문
- 예: start=5, end=10이면 → [5, 6, 7, 8, 9, 10] 총 6개
- 계산: 10 - 5 = 5 (틀림! 5개만 포함)
- 정답: 10 - 5 + 1 = 6 (맞음! 6개 모두 포함)

**수학적 공식**:
```
범위 [a, b]의 개수 = b - a + 1
```

### 2️⃣ 첫 배수 위치 계산 (모듈러 연산)

**핵심 공식**:
```cpp
long_t firstIdx = (square - (start % square)) % square;  // start~end 범위에서 square의 첫 배수 위치
```

**🎯 목표**: start~end 범위에서 square의 첫 번째 배수를 찾아야 함!

**📐 공식 유도 과정**:

제곱수 `square`의 배수는 `0, square, 2×square, 3×square, ...`

1️⃣ **start가 square로부터 얼마나 떨어져 있는지 계산**
```
start % square = start가 이전 배수를 지나친 거리
```

2️⃣ **다음 배수까지 얼마나 가야 하는지 계산**
```
square - (start % square) = 다음 배수까지의 거리
```

3️⃣ **예외 처리: start가 이미 배수인 경우**
```
start % square == 0이면 → 거리가 square가 되어버림
→ % square를 한 번 더 해서 0으로 만들어줌
```

**최종 공식**:
```
firstIdx = (square - (start % square)) % square
```

---

**예시 1**: start = 10, square = 4 (제곱수 4의 배수 찾기)

```
step 1. start % square     = 10 % 4 = 2        (10은 이전 배수 8을 2칸 지남)
step 2. square - 2          = 4 - 2  = 2        (다음 배수 12까지 2칸 남음)
step 3. 2 % square          = 2 % 4  = 2        (예외 아님, 그대로 2)

firstIdx = 2
실제 값  = start + firstIdx = 10 + 2 = 12

검증: 12 ÷ 4 = 3 (12는 4의 배수 ✅)
```

**시각화**:
```
     0   4   8   10  12  16  20  ... (실제 숫자)
     ↑   ↑   ↑   ↑   ↑   ↑   ↑
    4의 배수    start  첫 배수

start=10은 이전 배수(8)를 2칸 지났음
→ 다음 배수(12)까지 2칸 남음
→ sieve 배열에서 인덱스 2 위치 (= 실제 값 10+2=12)
```

---

**예시 2**: start = 12, square = 4 (start가 이미 배수인 경우)

```
step 1. start % square     = 12 % 4 = 0        (12는 이미 4의 배수)
step 2. square - 0          = 4 - 0  = 4        (다음 배수까지 4칸...?)
step 3. 4 % square          = 4 % 4  = 0        (예외 처리! 0으로 수정)

firstIdx = 0
실제 값  = start + firstIdx = 12 + 0 = 12

검증: 12 ÷ 4 = 3 (12는 4의 배수 ✅)
```

**시각화**:
```
     0   4   8   12  16  20  ... (실제 숫자)
     ↑   ↑   ↑   ↑   ↑   ↑
    4의 배수    start
                (이미 배수!)

start=12는 이미 4의 배수
→ 거리 0, 바로 여기서부터 시작
→ sieve 배열에서 인덱스 0 위치 (= 실제 값 12)
```

---

**💡 핵심 정리**:
```
(square - (start % square)) % square

= ┌ square - (start % square)  ← 다음 배수까지 거리
  └ % square                    ← 이미 배수면 0으로 만들기
```

### 3️⃣ 제곱수 범위 최적화

```cpp
for (long_t base = 2; base * base <= end; base++)  // end까지만 체크
```

**왜 √end까지만 체크하는가?**
- base^2 > end이면, base^2의 배수는 end를 초과함
- 따라서 start~end 범위에 영향을 주지 않음

**예시**: end = 17일 때
```
base=2 → 2^2 = 4  ≤ 17 ✅ (체크 필요)
base=3 → 3^2 = 9  ≤ 17 ✅ (체크 필요)
base=4 → 4^2 = 16 ≤ 17 ✅ (체크 필요)
base=5 → 5^2 = 25 > 17 ❌ (체크 불필요, 루프 종료)
```

### 4️⃣ unsigned long long 사용 이유

```cpp
typedef unsigned long long long_t;
```

**왜 unsigned를 사용하는가?**
- min, max 최대값: 10^12
- `long long` 범위: -2^63 ~ 2^63-1 (약 -9×10^18 ~ 9×10^18)
- 충분하지만, `base * base` 연산 시 오버플로우 가능성 존재
- `unsigned long long`은 0 ~ 2^64-1 (약 1.8×10^19)
- 음수가 없고 범위가 2배 → 더 안전

---

## 📊 예제 1 상세 계산 과정

**입력**: `1 10`

### 초기 상태
```
범위   :[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
sieve : [T, T, T, T, T, T, T, T, T, T]
         ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑
인덱스 :  0  1  2  3  4  5  6  7  8  9
실제값 :  1  2  3  4  5  6  7  8  9 10
```

### base=2, square=4 (제곱수 4의 배수 제거)
```
첫 배수 계산:
  firstIdx = (4 - (1 % 4)) % 4
           = (4 - 1) % 4
           = 3

마킹 위치: idx=3, idx=7 (간격 4)
실제 값:   4,    8

sieve: [T, T, T, F, T, T, T, F, T, T]
                 ↑              ↑
                4는            8은
                제곱ㄴㄴ수     제곱ㄴㄴ수
                아님!          아님!
```

### base=3, square=9 (제곱수 9의 배수 제거)
```
첫 배수 계산:
  firstIdx = (9 - (1 % 9)) % 9
           = (9 - 1) % 9
           = 8

마킹 위치: idx=8
실제 값:   9

sieve: [T, T, T, F, T, T, T, F, F, T]
                                ↑
                               9는
                               제곱ㄴㄴ수
                               아님!
```

### base=4일 때 루프 종료
```
base * base = 16 > 10이므로 종료
```

### 최종 결과
```
sieve: [T, T, T, F, T, T, T, F, F, T]
        ↑  ↑  ↑     ↑  ↑  ↑        ↑
        1  2  3     5  6  7       10

제곱ㄴㄴ수: 1, 2, 3, 5, 6, 7, 10 → 총 7개
```

**출력**: `7`

---

## 📊 예제 2 상세 계산 과정

**입력**: `15 15`

### 초기 상태
```
범위: [15]
sieve: [T]
        ↑
인덱스: 0
실제값: 15
```

### base=2, square=4 (제곱수 4의 배수 제거)
```
첫 배수 계산:
  firstIdx = (4 - (15 % 4)) % 4
           = (4 - 3) % 4
           = 1

마킹 위치: idx=1 (범위 초과, sieve.size()=1)
→ 마킹 없음
```

### base=3, square=9 (제곱수 9의 배수 제거)
```
첫 배수 계산:
  firstIdx = (9 - (15 % 9)) % 9
           = (9 - 6) % 9
           = 3

마킹 위치: idx=3 (범위 초과, sieve.size()=1)
→ 마킹 없음
```

### base=4일 때 루프 종료
```
base * base = 16 > 15이므로 종료
```

### 최종 결과
```
sieve: [T]
        ↑
       15

15는 제곱수로 나누어떨어지지 않음 → 제곱ㄴㄴ수!
```

**출력**: `1`

---

## 🔍 제곱ㄴㄴ수 판정 예시

### ✅ 제곱ㄴㄴ수
```
1  = 1             → 제곱수 배수 없음 ✅
2  = 2             → 제곱수 배수 없음 ✅
3  = 3             → 제곱수 배수 없음 ✅
5  = 5             → 제곱수 배수 없음 ✅
6  = 2 × 3         → 제곱수 배수 없음 ✅
7  = 7             → 제곱수 배수 없음 ✅
10 = 2 × 5         → 제곱수 배수 없음 ✅
```

### ❌ 제곱ㄴㄴ수 아님
```
4  = 2 × 2 = 4×1       → 4(2^2)로 나누어떨어짐 ❌
8  = 2 × 2 × 2 = 4×2   → 4(2^2)로 나누어떨어짐 ❌
9  = 3 × 3 = 9×1       → 9(3^2)로 나누어떨어짐 ❌
12 = 2 × 2 × 3 = 4×3   → 4(2^2)로 나누어떨어짐 ❌
16 = 2^4 = 4×4         → 4(2^2)로 나누어떨어짐 ❌
18 = 2 × 3^2 = 9×2     → 9(3^2)로 나누어떨어짐 ❌
```

---

## 🚨 주의사항

1. **unsigned long long 사용** : min, max가 10^12까지 가능
2. **상대 인덱싱** : `sieve[idx]`는 실제 값 `start+idx`를 의미
3. **첫 배수 공식** : `(square - (start % square)) % square`로 정확히 계산
4. **범위 체크** : `base * base <= end`로 불필요한 연산 제거
5. **배열 크기** : `end - start + 1` (양 끝 포함)
