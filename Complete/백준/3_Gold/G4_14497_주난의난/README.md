**📅 작성일**: 2025-10-08

## 🔗 문제 링크

https://www.acmicpc.net/problem/14497 (백준 14497번: 주난의 난(難))

**난이도**: Gold 4

---

## 🤔 접근법

큐를 2개를 사용해서 푸는 방식으로 접근함.

접근까지는 좋았는데, 세부적인 구현에 있어서, 시간이 좀 걸림.

문제는 해결했지만, 강사 정답 코드와 비교해 봄.

---

## 💡 핵심 아이디어

### 🔑 BFS + 2-Queue 전략

**파동 전파 규칙:**
- `0`을 만나면: 파동이 **계속 퍼짐** (같은 점프 내에서)
- `1`을 만나면: 파동이 **멈추고**, 해당 칸을 `0`으로 바꿈 (다음 점프 대기)
- `#`을 만나면: 범인 도착!

**2-Queue 방식:**

| 큐 | 역할 |
|---|------|
| **현재 큐 (currentQ)** | 같은 점프 내에서 `0`을 따라 계속 퍼지는 좌표들 |
| **다음 큐 (nextQ/temp)** | `1` 또는 `#`을 만나서 다음 점프에 탐색할 좌표들 |

**알고리즘 흐름:**
```
1. currentQ에서 좌표를 하나씩 꺼내서 상하좌우 탐색
2. 0 만나면 → currentQ에 추가 (같은 턴)
3. 1 또는 # 만나면 → nextQ에 추가 (다음 턴)
4. currentQ가 비면 → nextQ를 currentQ로 교체, 점프 카운트++
5. 범인(#) 위치에 도달하면 → 종료
```

---

## 🔀 Answer(성공 = 내 코드) vs Answer(정답 = 강사 코드) 비교

### ✅ 공통점 (동일한 아이디어)

| 항목 | 설명 |
|-----|------|
| **핵심 알고리즘** | BFS + 2-Queue 방식 |
| **파동 전파 규칙** | 0은 계속 퍼짐 / 1은 멈춤 |
| **점프 카운트** | 큐 교체마다 증가 |
| **시간복잡도** | O(N×M) |

---

### 🔄 차이점 (구현 방식)

#### 1️⃣ 종료 조건

| 구분 | Answer(성공) | Answer(정답) |
|-----|---------|---------|
| **종료 체크** | `y == arriveY && x == arriveX` | `a[endY][endX] != '0'` |
| **방식** | 범인 좌표에 도달 시 명시적 확인 | 범인 위치 칸이 `'0'`이 될 때까지 반복 |
| **장점** | 명확한 종료 조건 | 간결한 while문 |

**Answer(성공):**
```cpp
while (!currentQ.empty() || !nextQ.empty())
{
    // ...
    if (y == arriveY && x == arriveX)  // ← 명시적 체크
    {
        cout << moveCount << "\n";
        return 0;
    }
}
```

**Answer(정답):**
```cpp
while (a[endY][endX] != '0')  // ← 배열 값으로 체크
{
    // ...
    if (a[ny][nx] != '0')
    {
        a[ny][nx] = '0';  // ← 배열 직접 수정
    }
}
cout << visited[endY][endX] << "\n";
```

---

#### 2️⃣ 배열 수정 여부

| 구분 | Answer(성공) | Answer(정답) |
|-----|---------|---------|
| **배열 수정** | ❌ 수정 안 함 (원본 유지) | ✅ 수정함 (`a[ny][nx] = '0'`) |
| **visited 역할** | 방문 여부만 (1/0) | **점프 횟수 저장** |
| **결과 출력** | `moveCount` 변수 | `visited[endY][endX]` |

**Answer(성공):**
```cpp
visited[ny][nx] = 1;  // 방문 여부만 저장
// ...
cout << moveCount << "\n";  // 별도 변수로 출력
```

**Answer(정답):**
```cpp
visited[ny][nx] = cnt;  // 점프 횟수 저장
if (a[ny][nx] != '0')
{
    a[ny][nx] = '0';  // 배열 직접 수정!
}
// ...
cout << visited[endY][endX] << "\n";  // visited에서 바로 출력
```

---

#### 3️⃣ visited 배열 활용

| 구분 | Answer(성공) | Answer(정답) |
|-----|---------|---------|
| **visited 용도** | 방문 체크만 (boolean 역할) | 방문 체크 + 점프 횟수 저장 |
| **장점** | 명확한 역할 분리 | 메모리 효율적 (정보 압축) |
| **단점** | 별도 변수 필요 | visited가 다중 역할 |

---

#### 4️⃣ 큐 관리 방식

| 구분 | Answer(성공) | Answer(정답) |
|-----|---------|---------|
| **큐 선언** | `currentQ`, `nextQ` (전역 2개) | `currentQ` (전역), `temp` (지역) |
| **큐 교체** | `currentQ = nextQ` + `nextQ.pop()` | `currentQ = temp` |
| **점프 카운트** | 큐 교체 시 `moveCount++` | 매 턴 시작마다 `cnt++` |

**Answer(성공):**
```cpp
queue<pair<int,int>> currentQ, nextQ;  // 전역 2개

if (currentQ.empty())
{
    currentQ = nextQ;
    while (!nextQ.empty()) nextQ.pop();
    moveCount++;
}
```

**Answer(정답):**
```cpp
queue<pair<int,int>> currentQ;  // 전역 1개

while (a[endY][endX] != '0')
{
    cnt++;  // 먼저 증가
    queue<pair<int,int>> temp;  // 지역 변수
    // ...
    currentQ = temp;
}
```

---

### 🎯 어느 코드가 더 나은가?

| 측면 | Answer(성공) | Answer(정답) |
|-----|---------|---------|
| **가독성** | ✅ 높음 (명시적) | ⚠️ 중간 (배열 수정이 직관적이지 않음) |
| **메모리** | ⚠️ 중간 (큐 2개) | ✅ 효율적 (큐 1개) |
| **디버깅** | ✅ 쉬움 (원본 보존) | ⚠️ 어려움 (배열 변경됨) |
| **코드 길이** | ⚠️ 약간 김 | ✅ 간결함 |
| **안정성** | ✅ 원본 유지 | ⚠️ 배열 수정 (부작용 가능) |

---

### 📌 결론

- **Answer(성공)**: 명시적이고 안전한 방식 (원본 보존, 명확한 종료)
- **Answer(정답)**: 간결하고 효율적인 방식 (배열 수정, visited 다중 활용)

**두 방식 모두 정답이며, 상황에 따라 선택하면 됩니다!** 🎉

---

## ⏱️ 시간복잡도

**O(N × M)**
- 모든 칸을 최대 1번씩 방문
- N, M ≤ 300 → 최대 90,000번 연산

---

## 💾 공간복잡도

**O(N × M)**
- `a[301][301]`: 맵 배열
- `visited[301][301]`: 방문 체크 배열
- 큐: 최악의 경우 모든 칸 저장