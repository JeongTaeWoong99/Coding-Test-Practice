**📅 작성일**: 2025-10-13

## 🔗 문제 링크

[백준 11655번 - ROT13](https://www.acmicpc.net/problem/11655)

**난이도**: Bronze 1

---

## 🤔 접근법

ROT13은 알파벳을 13칸씩 밀어서 암호화하는 치환 암호(substitution cipher)이다.

- 'A' → 'N', 'B' → 'O', ..., 'N' → 'A', 'O' → 'B', ..., 'Z' → 'M'
- 소문자도 동일한 규칙 적용
- 숫자, 공백, 특수문자는 그대로 유지

문자열을 순회하면서 각 알파벳을 ROT13 규칙에 따라 변환한다.

---

## 💡 정답 풀이 방법

**알고리즘** : 문자열 순회 + 모듈러 연산

**핵심 아이디어**:
```
1. 문자열을 한 글자씩 순회
2. 대문자(A~Z)인지, 소문자(a~z)인지 판별
3. ROT13 변환 공식 적용
4. 알파벳이 아닌 경우 그대로 출력
```

**시간 복잡도**: O(N) - N = 문자열 길이

**공간 복잡도**: O(N) - 결과 문자열 저장

---

## 📊 단계별 분석

#### **Step 1: `S[i] - 'A'`** → 문자를 숫자로 변환

```
'A' - 'A' = 0
'B' - 'A' = 1
'C' - 'A' = 2
...
'Z' - 'A' = 25
```

**✅ 목적**: 알파벳을 0~25 범위의 정수로 변환
- 배열 인덱스처럼 사용 가능한 숫자로 만들기
- 수학적 연산을 수행하기 위한 기초 작업

<br>

#### **Step 2: `+ 13`** → 13칸 이동

```
'A' (0) + 13 = 13  → 'N'
'B' (1) + 13 = 14  → 'O'
'M' (12) + 13 = 25 → 'Z'
'N' (13) + 13 = 26 → ???? (26은 알파벳 범위 초과!)
'Z' (25) + 13 = 38 → ???? (38은 알파벳 범위 초과!)
```

**⚠️ 문제 발생**: 'N' 이후의 알파벳들은 13을 더하면 26 이상이 되어 범위를 벗어남

<br>

#### **Step 3: `% 26`** → 26으로 나눈 나머지 (순환 구조)

```
'A' (0) + 13 = 13  → 13 % 26 = 13  → 'N' ✅
'M' (12) + 13 = 25 → 25 % 26 = 25 → 'Z' ✅
'N' (13) + 13 = 26 → 26 % 26 = 0  → 'A' ✅ (다시 처음으로!)
'O' (14) + 13 = 27 → 27 % 26 = 1  → 'B' ✅
'Z' (25) + 13 = 38 → 38 % 26 = 12 → 'M' ✅
```

**✅ 핵심**: `% 26` (모듈러 연산)은 **순환 구조**를 만들어준다
- 알파벳 범위(0~25)를 벗어나면 다시 처음으로 돌아옴
- 마치 시계의 시침이 12시를 넘어가면 다시 1시가 되는 것과 같은 원리

<br>

#### **Step 4: `+ 'A'`** → 다시 문자로 변환

```
13 + 'A' = 'N'
0 + 'A' = 'A'
12 + 'A' = 'M'
```

**✅ 목적**: 숫자(0~25)를 다시 알파벳 문자('A'~'Z')로 변환
- Step 1에서 'A'를 뺐으니, 마지막에 다시 'A'를 더해서 복원

---

### 📌 전체 변환 표

| 원본 | 숫자 | +13 | %26 | +65('A') | 결과 |
|------|------|-----|-----|----------|------|
| A    | 0    | 13  | 13  | 'N'      | N    |
| B    | 1    | 14  | 14  | 'O'      | O    |
| C    | 2    | 15  | 15  | 'P'      | P    |
| ...  | ...  | ... | ... | ...      | ...  |
| M    | 12   | 25  | 25  | 'Z'      | Z    |
| N    | 13   | 26  | **0**   | 'A'      | A    |
| O    | 14   | 27  | **1**   | 'B'      | B    |
| ...  | ...  | ... | ... | ...      | ...  |
| Z    | 25   | 38  | **12**  | 'M'      | M    |

**⚠️ 빨간색 부분**: `% 26`이 없다면 범위를 벗어나서 이상한 문자가 나올 것!

<br>

###  왜 `% 26`이 필수인가?

만약 `% 26` 없이 다음과 같이 작성한다면:

```cpp
// ❌ 잘못된 코드
temp += (S[i] - 'A' + 13 + 'A');  // % 26 없음!
```

**문제 발생**:
```
'N' (13) → 13 + 13 + 65 = 91 = '['  ❌ (91은 대괄호!)
'Z' (25) → 25 + 13 + 65 = 103 = 'g' ❌ (103은 소문자 g!)
```

**✅ 결론**: `% 26`이 없으면 알파벳 범위(65~90)를 벗어나 **이상한 문자**가 나온다!

---